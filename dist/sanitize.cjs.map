{"version":3,"sources":["../src/parts/sanitize.ts","../src/parts/util.ts"],"sourcesContent":["// sanitize.ts\nimport { endsWith, toLowerCase } from \"./util\";\n\n/**\n * A basic tool for HTML entities encoding.\n * Encodes HTML entities like &, <, >, \", and '.\n * @param str The source string to encode.\n * @returns The encoded string.\n */\nexport const encodeEntities = (str: string): string =>\n  str.replace(/[&<>\"']/g, (char) => ({\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n  }[char] || /* istanbul ignore next @preserve */ char));\n\n/**\n * Sanitizes a URL to prevent XSS vulnerabilities.\n * Removes potentially dangerous URL schemes like javascript:, data:, and vbscript:.\n * @param url The URL to sanitize.\n * @returns The sanitized URL, or an empty string if the URL is unsafe.\n */\nexport const sanitizeUrl = (url: string): string => {\n  const decoded = decodeURIComponent(url.trim());\n  if (/^(?:javascript|data|vbscript):/i.test(decoded)) return \"\";\n  return encodeEntities(decoded);\n};\n\n/**\n * Sanitizes HTML attribute values to prevent XSS vulnerabilities.\n * Encodes HTML entities and sanitizes URLs for specific attributes like src, href, action,\n * formaction, and attributes ending with 'url'.\n * @param attrName The attribute name.\n * @param initialValue The attribute value to sanitize.\n * @returns The sanitized attribute value.\n */\nexport const sanitizeAttrValue = (\n  attrName: string,\n  initialValue: string,\n): string => {\n  if (!initialValue) return \"\";\n  const name = toLowerCase(attrName);\n  const value = initialValue.trim();\n\n  if (\n    name === \"src\" ||\n    name === \"href\" ||\n    name === \"action\" ||\n    name === \"formaction\" ||\n    endsWith(name, \"url\")\n  ) {\n    return sanitizeUrl(value);\n  }\n\n  return encodeEntities(value);\n};\n","// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n} from \"./types\";\n\n// general utils\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (str: string, prefix: string): boolean =>\n  str.startsWith(prefix);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (str: string, suffix: string): boolean =>\n  str.endsWith(suffix);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\nexport const DOM_ERROR = \"DomError:\";\nexport const PARSER_ERROR = \"ParserError:\";\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACkBO,IAAM,cAAc,CAAC,QAAwB,IAAI,YAAY;AAwB7D,IAAM,WAAW,CAAC,KAAa,WACpC,IAAI,SAAS,MAAM;;;ADlCd,IAAM,iBAAiB,CAAC,QAC7B,IAAI,QAAQ,YAAY,CAAC,UAAU;AAAA,EACjC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACP,GAAE,IAAI;AAA0C,IAAK;AAQhD,IAAM,cAAc,CAAC,QAAwB;AAClD,QAAM,UAAU,mBAAmB,IAAI,KAAK,CAAC;AAC7C,MAAI,kCAAkC,KAAK,OAAO,EAAG,QAAO;AAC5D,SAAO,eAAe,OAAO;AAC/B;AAUO,IAAM,oBAAoB,CAC/B,UACA,iBACW;AACX,MAAI,CAAC,aAAc,QAAO;AAC1B,QAAM,OAAO,YAAY,QAAQ;AACjC,QAAM,QAAQ,aAAa,KAAK;AAEhC,MACE,SAAS,SACT,SAAS,UACT,SAAS,YACT,SAAS,gBACT,SAAS,MAAM,KAAK,GACpB;AACA,WAAO,YAAY,KAAK;AAAA,EAC1B;AAEA,SAAO,eAAe,KAAK;AAC7B;","names":[]}