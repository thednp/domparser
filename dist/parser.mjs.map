{"version":3,"sources":["../src/parts/util.ts","../src/parts/parser.ts"],"sourcesContent":["// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n} from \"./types\";\n\n// general utils\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (str: string, prefix: string): boolean =>\n  str.startsWith(prefix);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (str: string, suffix: string): boolean =>\n  str.endsWith(suffix);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\nexport const DOM_ERROR = \"DomError:\";\nexport const PARSER_ERROR = \"ParserError:\";\n","import type {\n  ChildLike,\n  CommentLike,\n  DOMNode,\n  GetAttributesOptions,\n  HTMLToken,\n  NodeLike,\n  NodeLikeAttributes,\n  ParseResult,\n  ParserOptions,\n  RootLike,\n  TextLike,\n} from \"./types\";\n\nimport {\n  charCodeAt,\n  endsWith,\n  fromCharCode,\n  isTag,\n  selfClosingTags,\n  startsWith,\n  toLowerCase,\n  toUpperCase,\n} from \"./util\";\n\n/**\n * Get attributes from a string token and return an object\n * @param tagStr the string token\n * @param config an optional set of options\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  config?: Partial<GetAttributesOptions>,\n): NodeLikeAttributes => {\n  const { sanitizeFn, unsafeAttrs } = config || {};\n  const attrs: NodeLikeAttributes = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = attrRegex.exec(attrStr))) {\n    const [, name, d, s, u] = match;\n    const value = d ?? s ?? u ?? \"\";\n    if (name && name !== \"/\" && (!unsafeAttrs?.has(toLowerCase(name)))) {\n      attrs[name] = sanitizeFn ? sanitizeFn(toLowerCase(name), value) : value;\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Tokenizes an HTML string into an array of HTML tokens.\n * These tokens represent opening tags, closing tags, text content, and comments.\n * @param html The HTML string to tokenize.\n * @returns An array of `HTMLToken` objects.\n */\nexport const tokenize = (html: string): HTMLToken[] => {\n  const tokens: HTMLToken[] = [];\n  let token = \"\",\n    inTag = false,\n    inQuote = false,\n    quote = 0,\n    isComment = false;\n\n  for (let i = 0; i < html.length; i++) {\n    const char = charCodeAt(html, i);\n\n    if (isComment) {\n      token += fromCharCode(char);\n      if (endsWith(token, \"--\")) {\n        /* istanbul ignore else @preserve */\n        if (charCodeAt(html, i + 1) === 62 /* > */) {\n          tokens.push({\n            nodeType: \"comment\",\n            value: token.trim(),\n            isSC: false,\n          });\n          token = \"\";\n          isComment = false;\n          i++;\n        }\n      }\n      continue;\n    }\n\n    if (inTag && (char === 34 || char === 39)) { // \" or ' | 0x22 or 0x27\n      if (!inQuote) {\n        quote = char;\n        inQuote = true;\n      } else if (char === quote) inQuote = false;\n      token += fromCharCode(char);\n      continue;\n    }\n\n    if (char === 60 /* 0x3c */ && !inQuote) { // <\n      token.trim() && tokens.push({\n        nodeType: \"text\",\n        // value: encodeEntities(token.trim()),\n        value: (token.trim()),\n        isSC: false,\n      });\n      token = \"\";\n      inTag = true;\n      if (\n        charCodeAt(html, i + 1) === 33 /* ! | 0x21 */ &&\n        charCodeAt(html, i + 2) === 45 /* - | 0x2d */ &&\n        charCodeAt(html, i + 3) === 45 /* - | 0x2d */\n      ) {\n        isComment = true;\n        token += \"!--\";\n        i += 3;\n        continue;\n      }\n    } else if (char === 62 /* 0x3e */ && !inQuote && inTag && !isComment) { // > | 0x3e\n      /* istanbul ignore else @preserve */\n      if (token) {\n        const isSC = endsWith(token, \"/\");\n        const isDocType = startsWith(token, \"!doctype\");\n\n        tokens.push({\n          nodeType: isDocType ? \"doctype\" : \"tag\",\n          value: isSC ? token.slice(0, -1).trim() : token.trim(),\n          isSC,\n        });\n      }\n      token = \"\";\n      inTag = false;\n    } else {\n      token += fromCharCode(char);\n    }\n  }\n\n  token.trim() && tokens.push({\n    nodeType: \"text\",\n    // value: encodeEntities(token.trim()),\n    value: (token.trim()),\n    isSC: false,\n  });\n  return tokens;\n};\n\n/**\n * **Parser**\n *\n * A tiny yet very fast and powerful parser that\n * takes a string of HTML and returns a DOM tree representation.\n *\n * **Features**\n * * The **Parser** is around 1.2Kb and is optimized for speed and memory efficiency.\n * * It handles basic HTML elements, custom elements, UI frameworks components,\n * special attributes, and text and comment nodes.\n * * It provides sanitization options for specific attributes\n * and options to filter tags and unsafe attributes; _by default the filters are empty_.\n * * You can make use of its sanitization tools in your application or use any\n * sanitization at your disposal.\n *\n * The DOM representation is a plain object with the following structure:\n * ```ts\n *  type CommentLike = {\n *   nodeName: \"#comment\";\n *   nodeValue: string;\n * };\n *  type TextLike = {\n *   nodeName: \"#text\";\n *   nodeValue: string;\n * };\n *  type NodeLike = {\n *   tagName: string;\n *   nodeName: string;\n *   attributes: Record<string, string>;\n *   children: NodeLike[];\n *   childNodes: (NodeLike | TextLike | CommentLike)[];\n * };\n *  type RootLike = {\n *   nodeName: string;\n *   doctype?: string;\n *   all: NodeLike[];\n *   children: NodeLike[];\n *   childNodes: (NodeLike | TextLike | CommentLike)[];\n * };\n * ```\n *\n * @example\n * ```ts\n * const config = {\n *   // Sanitize function\n *   sanitizeFn?: myFunction(attrName: string, attrValue: string) => string,\n *   // Callback on new nodes\n *   onNodeCallback?: myFunction(node: NodeLike) => void,\n *   // Common dangerous tags that could lead to XSS attacks\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS attacks\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const parser = Parser(config);\n * const { root, components, tags } = parser.parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a RootLike node, \"components\" is an array of component names, \"tags\" is an array of tag names\n * ```\n *\n * @param config an optional configuration object\n * @returns the parsed result\n */\nexport function Parser(config: Partial<ParserOptions> = {}) {\n  // Common dangerous tags that could lead to XSS\n  let unsafeTags = new Set<string>();\n\n  // Unsafe attributes that could lead to XSS\n  let unsafeAttrs = new Set<string>();\n\n  // Apply config\n  const { filterTags, filterAttrs, onNodeCallback, sanitizeFn } = config;\n  if (filterTags?.length) unsafeTags = new Set(filterTags);\n  if (filterAttrs?.length) unsafeAttrs = new Set(filterAttrs);\n  const getAttrOptions = { unsafeAttrs } as GetAttributesOptions;\n  // don't override the default function unless it's actualy set\n  if (typeof sanitizeFn === \"function\") getAttrOptions.sanitizeFn = sanitizeFn;\n\n  return {\n    parseFromString(htmlString?: string) {\n      const root: RootLike = {\n        nodeName: \"#document\",\n        childNodes: [],\n        children: [],\n        all: [],\n      };\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack: (RootLike | NodeLike)[] = [root];\n      const tagStack: string[] = [];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      let parentIsSafe = true;\n      let newNode: ChildLike;\n\n      const append = (\n        node: ChildLike,\n        parent: RootLike | DOMNode | NodeLike,\n      ) => {\n        // here we call the callback coming from Dom\n        // or any other parent functionality\n        // we allow that to store the DOM tree\n        if (onNodeCallback) {\n          onNodeCallback(node, parent as DOMNode, root);\n        } else {\n          if (isTag(node)) {\n            parent.children.push(node);\n            root.all.push(node);\n          }\n          parent.childNodes.push(node);\n        }\n      };\n\n      tokenize(htmlString).forEach((token) => {\n        const { nodeType, value, isSC } = token;\n        // Skip doctype, but store it as a root property\n        if (nodeType === \"doctype\") {\n          root.doctype = `<${value}>`;\n          return;\n        }\n        const currentParent = stack[stack.length - 1];\n\n        if ([\"text\", \"comment\"].includes(nodeType)) {\n          newNode = {\n            nodeName: `#${nodeType}`,\n            nodeValue: nodeType === \"text\" ? value : `<${value}>`,\n          } as TextLike | CommentLike;\n          append(newNode, currentParent);\n          return;\n        }\n\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC || selfClosingTags.has(tagNameLower);\n\n        // Tag Matching Detection Logic\n        if (!isSelfClosing) {\n          // Start Tag (and not self-closing)\n          if (!isClosing) {\n            // Push tag name onto the tag stack\n            tagStack.push(tagName);\n            // Closing Tag\n          } else {\n            // Pop the last opened tag\n            const expectedTag = tagStack.pop();\n            if (expectedTag !== tagName) {\n              if (expectedTag === undefined) {\n                throw new Error(\n                  `ParserError: Mismatched closing tag: </${tagName}>. No open tag found.`,\n                );\n              } else {\n                throw new Error(\n                  `ParserError: Mismatched closing tag: </${tagName}>. Expected closing tag for <${expectedTag}>.`,\n                );\n              }\n            }\n          }\n        }\n\n        // Skip unsafe tags\n        if (unsafeTags.has(tagNameLower)) {\n          if (isClosing) {\n            parentIsSafe = true;\n          } else {\n            parentIsSafe = false;\n          }\n          return;\n        }\n\n        if (!parentIsSafe) return;\n\n        // Register tag/component type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          newNode = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getAttributes(value, getAttrOptions),\n            children: [],\n            childNodes: [],\n          } as NodeLike;\n\n          const charset = newNode.attributes?.charset;\n          if (tagName === \"meta\" && charset) {\n            root.charset = toUpperCase(charset);\n          }\n\n          append(newNode, currentParent);\n          !isSelfClosing && stack.push(newNode);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      });\n\n      // Check for unclosed tags at the end\n      // actually not possible to reach this point\n      // since it throws at first mismatch\n      // if (tagStack.length > 0) {\n      //   const unclosedTag = tagStack.pop();\n      //   throw new Error(`ParserError: Unclosed tag: <${unclosedTag}>.`);\n      // }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies ParseResult;\n    },\n  };\n}\n"],"mappings":"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","names":[]}