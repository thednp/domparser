{"version":3,"sources":["/home/artae/Work/Github/domparser/dist/chunk-MYYMTVW7.cjs","../src/parts/util.ts"],"names":[],"mappings":"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","file":"/home/artae/Work/Github/domparser/dist/chunk-MYYMTVW7.cjs","sourcesContent":[null,"// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  GetAttributesOptions,\n  HTMLToken,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n  TokenizerOptions,\n} from \"./types.ts\";\n\n// general utils\n\nexport const ATTR_REGEX = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n/**\n * Get attributes from a string token and return an object\n * @param tagStr the string token\n * @returns the attributes object\n */\nexport const getBaseAttributes = (tagStr: string) => {\n  const attrs: NodeLikeAttributes = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: RegExpExecArray | null;\n\n  while ((match = ATTR_REGEX.exec(attrStr))) {\n    const [, name, d, s, u] = match;\n    name !== \"/\" && (attrs[name] = d ?? s ?? u ?? \"\");\n  }\n\n  return attrs;\n};\n\n/**\n * Get attributes from a string token and return an object.\n * In addition to the base tool, this also filters configured\n * unsafe attributes.\n * @param tagStr the string token\n * @param config an optional set of options\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  config?: Partial<GetAttributesOptions>,\n): NodeLikeAttributes => {\n  const { unsafeAttrs } = config || {};\n  const baseAttrs = getBaseAttributes(tagStr);\n  const attrs: NodeLikeAttributes = {};\n\n  for (const [key, value] of Object.entries(baseAttrs)) {\n    if (!unsafeAttrs || !unsafeAttrs?.has(toLowerCase(key))) {\n      attrs[key] = value;\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (\n  str: string,\n  prefix: string,\n  position?: number,\n): boolean => str.startsWith(prefix, position);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (\n  str: string,\n  suffix: string,\n  position?: number,\n): boolean => str.endsWith(suffix, position);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Trim a string value.\n * @param str A string value\n * @returns The trimmed value of the same string.\n */\nexport const trim = (str: string) => str.trim();\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"?xml\",\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\nexport const escape = (str: string) => {\n  if ((str === null) || (str === \"\")) {\n    return false;\n  } else {\n    str = str.toString();\n  }\n\n  const map: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#039;\",\n  };\n\n  return str.replace(/[&<>\"']/g, (m) => {\n    return map[m];\n  });\n};\n\nexport const DOM_ERROR = \"DomParserError:\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024; // 65536 = 64KB\nconst DEFAULT_MAX_SCRIPT_SIZE = 128 * 1024; // 131072 = 128KB\n\n/**\n * Tokenizes an HTML string into an array of HTML tokens.\n * These tokens represent opening tags, closing tags, text content, and comments.\n * @param html The HTML string to tokenize.\n * @returns An array of `HTMLToken` objects.\n */\n\nexport const tokenize = (\n  html: string,\n  options: TokenizerOptions = {},\n): HTMLToken[] => {\n  const {\n    maxScriptSize = DEFAULT_MAX_SCRIPT_SIZE,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  } = options;\n\n  const specialTags = [\"script\", \"style\"] as const;\n  const tokens: HTMLToken[] = [];\n  const len = html.length;\n\n  let token = \"\";\n  let scriptContent = \"\";\n  let inTag = false;\n  let inQuote = false;\n  let quote = 0;\n  let inTemplate = false;\n  let inComment = false;\n  let inCDATA = false;\n  let inStyleScript = false;\n  let currentChunkStart = 0;\n\n  while (currentChunkStart < len) {\n    const chunkEnd = Math.min(currentChunkStart + chunkSize, len);\n    const chunk = html.slice(currentChunkStart, chunkEnd);\n\n    for (let i = 0; i < chunk.length; i++) {\n      const globalIndex = currentChunkStart + i;\n      const char = charCodeAt(chunk, i);\n\n      if (inStyleScript) {\n        const endSpecialTag = specialTags.find((t) =>\n          startsWith(html, `/${t}`, globalIndex + 1)\n        );\n\n        if (char === 60 && endSpecialTag && !inTemplate && !inQuote) { // <\n          // istanbul ignore else @preserve\n          if (scriptContent.length < maxScriptSize) {\n            tokens.push({\n              tokenType: \"text\",\n              value: trim(scriptContent),\n              isSC: false,\n            });\n          }\n          tokens.push({\n            tokenType: \"tag\",\n            value: \"/\" + endSpecialTag,\n            isSC: false,\n          });\n          scriptContent = \"\";\n          inStyleScript = false;\n          i += endSpecialTag.length + 2;\n        } else {\n          // istanbul ignore next @preserve - don't crash the test!!\n          if (scriptContent.length >= maxScriptSize) {\n            // Once we hit the limit, just skip content until closing tag\n            continue;\n          }\n          if (char === 96) {\n            inTemplate = !inTemplate;\n          } else if (!inTemplate && (char === 34 || char === 39)) {\n            // istanbul ignore else @preserve\n            if (!inQuote) {\n              quote = char;\n              inQuote = true;\n            } else if (char === quote) {\n              inQuote = false;\n            }\n          }\n          scriptContent += fromCharCode(char);\n        }\n        continue;\n      }\n\n      if (inComment) {\n        token += fromCharCode(char);\n        if (endsWith(token, \"--\") && charCodeAt(html, globalIndex + 1) === 62) {\n          tokens.push({\n            tokenType: \"comment\",\n            value: `<${trim(token)}>`,\n            isSC: false,\n          });\n          inComment = false;\n          token = \"\";\n          i += 1;\n        }\n        continue;\n      }\n\n      if (inCDATA) {\n        token += fromCharCode(char);\n        if (endsWith(token, \"]]\") && charCodeAt(html, globalIndex + 1) === 62) {\n          tokens.push({\n            tokenType: \"text\",\n            value: `<${escape(trim(token))}>`,\n            isSC: false,\n          });\n          inCDATA = false;\n          token = \"\";\n          i += 1;\n        }\n        continue;\n      }\n\n      if (\n        (inTag && token.includes(\"=\")) &&\n        (char === 34 || char === 39)\n      ) {\n        if (!inQuote) {\n          quote = char;\n          inQuote = true;\n        } else if (char === quote) {\n          inQuote = false;\n        }\n        token += fromCharCode(char);\n        continue;\n      }\n\n      if (\n        char === 60 && !inQuote && !inTemplate && !inStyleScript && !inCDATA &&\n        !inComment\n      ) {\n        trim(token) &&\n          tokens.push({\n            tokenType: \"text\",\n            value: trim(token),\n            isSC: false,\n          });\n        token = \"\";\n\n        if (startsWith(html, \"!--\", globalIndex + 1)) {\n          inComment = true;\n          token += \"!--\";\n          i += 3;\n          continue;\n        }\n        if (startsWith(html, \"![CDATA[\", globalIndex + 1)) {\n          inCDATA = true;\n          token += \"![CDATA[\";\n          i += 8;\n          continue;\n        }\n        inTag = true;\n      } else if (\n        char === 62 && inTag && !inTemplate && !inComment &&\n        !inStyleScript && !inCDATA\n      ) {\n        const startSpecialTag = specialTags.find((t) =>\n          t === token || startsWith(token, t)\n        );\n        if (startSpecialTag && !endsWith(token, \"/\")) {\n          inStyleScript = true;\n        }\n\n        const isDocType = startsWith(toLowerCase(token), \"!doctype\");\n\n        // istanbul ignore else @preserve\n        if (token) {\n          const isSC = endsWith(token, \"/\");\n          const [tagName] = token.split(/\\s/);\n          const value = inQuote ? tagName + (isSC ? \"/\" : \"\") : token;\n          tokens.push({\n            tokenType: isDocType ? \"doctype\" : \"tag\",\n            value: isSC ? trim(value.slice(0, -1)) : trim(value),\n            isSC,\n          });\n        }\n        token = \"\";\n        inTag = false;\n        inQuote = false;\n      } else {\n        token += fromCharCode(char);\n      }\n    }\n    currentChunkStart = chunkEnd;\n  }\n\n  const lastToken = trim(token);\n  if (lastToken) {\n    tokens.push({\n      tokenType: \"text\",\n      value: lastToken,\n      isSC: false,\n    });\n  }\n\n  return tokens;\n};\n"]}