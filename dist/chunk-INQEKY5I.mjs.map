{"version":3,"sources":["../src/parts/parser.ts"],"sourcesContent":["// parser.ts\nimport {\n  getBaseAttributes,\n  selfClosingTags,\n  tokenize,\n  toLowerCase,\n  toUpperCase,\n} from \"./util.ts\";\nimport type {\n  CommentLike,\n  NodeLike,\n  ParseResult,\n  RootLike,\n  TextLike,\n} from \"./types\";\n\n/**\n * **Parser**\n *\n * A tiny yet very fast and powerful parser that takes a string of HTML\n * and returns a DOM tree representation. In benchmarks it shows up to\n * 60x faster performance when compared to jsdom.\n *\n * @example\n * ```ts\n * const { root, components, tags } = Parser().parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a RootLike node,\n * // > \"components\" is an array of component names,\n * // > \"tags\" is an array of tag names.\n * ```\n *\n * @returns The result of the parser.\n */\nexport function Parser() {\n  return {\n    parseFromString(htmlString?: string): ParseResult {\n      const root: RootLike = { nodeName: \"#document\", children: [] };\n      if (!htmlString) return { root, tags: [], components: [] };\n\n      const stack: (RootLike | NodeLike)[] = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      const tokens = tokenize(htmlString);\n      const tLen = tokens.length;\n\n      for (let i = 0; i < tLen; i += 1) {\n        const { tokenType, value, isSC } = tokens[i];\n        const currentParent = stack[stack.length - 1];\n        if (tokenType === \"doctype\") continue;\n\n        if ([\"text\", \"comment\"].includes(tokenType)) {\n          currentParent.children.push(\n            {\n              nodeName: `#${tokenType}`,\n              nodeValue: value,\n            } as CommentLike | TextLike,\n          );\n          continue;\n        }\n\n        const isClosing = value.startsWith(\"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC ||\n          selfClosingTags.has(tagNameLower);\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) ||\n            tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node: NodeLike = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getBaseAttributes(value),\n            children: [],\n          };\n\n          currentParent.children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      };\n    },\n  };\n}\n"],"mappings":";;;;;;;;;AAiCO,SAAS,SAAS;AACvB,SAAO;AAAA,IACL,gBAAgB,YAAkC;AAChD,YAAM,OAAiB,EAAE,UAAU,aAAa,UAAU,CAAC,EAAE;AAC7D,UAAI,CAAC,WAAY,QAAO,EAAE,MAAM,MAAM,CAAC,GAAG,YAAY,CAAC,EAAE;AAEzD,YAAM,QAAiC,CAAC,IAAI;AAC5C,YAAM,aAAa,oBAAI,IAAY;AACnC,YAAM,OAAO,oBAAI,IAAY;AAC7B,YAAM,SAAS,SAAS,UAAU;AAClC,YAAM,OAAO,OAAO;AAEpB,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK,GAAG;AAChC,cAAM,EAAE,WAAW,OAAO,KAAK,IAAI,OAAO,CAAC;AAC3C,cAAM,gBAAgB,MAAM,MAAM,SAAS,CAAC;AAC5C,YAAI,cAAc,UAAW;AAE7B,YAAI,CAAC,QAAQ,SAAS,EAAE,SAAS,SAAS,GAAG;AAC3C,wBAAc,SAAS;AAAA,YACrB;AAAA,cACE,UAAU,IAAI,SAAS;AAAA,cACvB,WAAW;AAAA,YACb;AAAA,UACF;AACA;AAAA,QACF;AAEA,cAAM,YAAY,MAAM,WAAW,GAAG;AACtC,cAAM,UAAU,YAAY,MAAM,MAAM,CAAC,IAAI,MAAM,MAAM,QAAQ,EAAE,CAAC;AACpE,cAAM,eAAe,YAAY,OAAO;AACxC,cAAM,gBAAgB,QACpB,gBAAgB,IAAI,YAAY;AAGlC,SAAC,QAAQ,CAAC,MAAM,YAAY,QAAQ,CAAC,CAAC,KAClC,QAAQ,SAAS,GAAG,IACpB,aACA,MAAM,IAAI,OAAO;AAErB,YAAI,CAAC,WAAW;AACd,gBAAM,OAAiB;AAAA,YACrB;AAAA,YACA,UAAU,YAAY,OAAO;AAAA,YAC7B,YAAY,kBAAkB,KAAK;AAAA,YACnC,UAAU,CAAC;AAAA,UACb;AAEA,wBAAc,SAAS,KAAK,IAAI;AAChC,WAAC,iBAAiB,MAAM,KAAK,IAAI;AAAA,QACnC,WAAW,CAAC,iBAAiB,MAAM,SAAS,GAAG;AAC7C,gBAAM,IAAI;AAAA,QACZ;AAAA,MACF;AAEA,aAAO;AAAA,QACL;AAAA,QACA,YAAY,MAAM,KAAK,UAAU;AAAA,QACjC,MAAM,MAAM,KAAK,IAAI;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AACF;","names":[]}