{"version":3,"sources":["/home/artae/Work/Github/domparser/dist/parser.cjs","../src/parts/util.ts","../src/parts/parser.ts"],"names":[],"mappings":"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","file":"/home/artae/Work/Github/domparser/dist/parser.cjs","sourcesContent":[null,"// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  GetAttributesOptions,\n  HTMLToken,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n} from \"./types.ts\";\n\n// general utils\n\nexport const ATTR_REGEX = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n/**\n * Get attributes from a string token and return an object\n * @param tagStr the string token\n * @returns the attributes object\n */\nexport const getBaseAttributes = (tagStr: string) => {\n  const attrs: NodeLikeAttributes = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: RegExpExecArray | null;\n\n  while ((match = ATTR_REGEX.exec(attrStr))) {\n    const [, name, d, s, u] = match;\n    name !== \"/\" && (attrs[name] = d ?? s ?? u ?? \"\");\n  }\n\n  return attrs;\n};\n\n/**\n * Get attributes from a string token and return an object.\n * In addition to the base tool, this also filters configured\n * unsafe attributes and sanitization.\n * @param tagStr the string token\n * @param config an optional set of options\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  config?: Partial<GetAttributesOptions>,\n): NodeLikeAttributes => {\n  const { unsafeAttrs } = config || {};\n  const baseAttrs = getBaseAttributes(tagStr);\n  const attrs: NodeLikeAttributes = {};\n\n  for (const [key, value] of Object.entries(baseAttrs)) {\n    if (!unsafeAttrs || !unsafeAttrs?.has(toLowerCase(key))) {\n      attrs[key] = value;\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (\n  str: string,\n  prefix: string,\n  position?: number,\n): boolean => str.startsWith(prefix, position);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (\n  str: string,\n  suffix: string,\n  position?: number,\n): boolean => str.endsWith(suffix, position);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Trim a string value.\n * @param str A string value\n * @returns The trimmed value of the same string.\n */\nexport const trim = (str: string) => str.trim();\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\n/**\n * Tokenizes an HTML string into an array of HTML tokens.\n * These tokens represent opening tags, closing tags, text content, and comments.\n * @param html The HTML string to tokenize.\n * @returns An array of `HTMLToken` objects.\n */\nexport const tokenize = (html: string): HTMLToken[] => {\n  const specialTags = [\"script\", \"style\"];\n  const tokens: HTMLToken[] = [];\n  const len = html.length;\n  let token = \"\",\n    inTag = false,\n    inQuote = false,\n    quote = 0,\n    inTemplate = false,\n    inComment = false,\n    inStyleScript = false;\n\n  for (let i = 0; i < len; i++) {\n    const char = charCodeAt(html, i);\n\n    if (inComment) {\n      token += fromCharCode(char);\n      /* istanbul ignore else @preserve */\n      if (endsWith(token, \"--\") && charCodeAt(html, i + 1) === 62 /* > */) {\n        tokens.push({\n          nodeType: \"comment\",\n          value: `<${trim(token)}>`,\n          isSC: false,\n        });\n        inComment = false;\n        token = \"\";\n        i += 1;\n      }\n      continue;\n    }\n\n    if (inStyleScript) {\n      const endSpecialTag = specialTags.find((t) =>\n        startsWith(html, `/${t}`, i + 1)\n      );\n      if (char === 60 && endSpecialTag && !inTag && !inTemplate && !inQuote) { // <\n        inStyleScript = false;\n      }\n      if (char === 96) { // ` | 0x60\n        inTemplate = !inTemplate;\n      }\n    }\n\n    // \" or ' | 0x22 or 0x27\n    if (\n      (inTag || inStyleScript) && (char === 34 || char === 39)\n    ) {\n      if (!inQuote) {\n        quote = char;\n        inQuote = true;\n      } else if (char === quote) {\n        inQuote = false;\n      }\n\n      token += fromCharCode(char);\n      continue;\n    }\n\n    // else\n    if (char === 60 && !inQuote && !inTemplate && !inStyleScript) { // <\n      trim(token) &&\n        tokens.push({\n          nodeType: \"text\",\n          value: trim(token),\n          isSC: false,\n        });\n      token = \"\";\n      inTag = true;\n\n      if (startsWith(html, \"!--\", i + 1)) {\n        inComment = true;\n        token += \"!--\";\n        i += 3;\n        continue;\n      }\n    } else if (\n      char === 62 && inTag && !inQuote && !inTemplate && !inComment &&\n      !inStyleScript\n    ) { // >\n      const startSpecialTag = specialTags.find((t) =>\n        t === token || startsWith(token, t)\n      );\n      if (startSpecialTag) {\n        inStyleScript = true;\n      }\n      // handle doctype tag\n      const isDocType = startsWith(toLowerCase(token), \"!doctype\");\n      /* istanbul ignore else @preserve */\n      if (token) {\n        const isSC = endsWith(token, \"/\");\n        tokens.push({\n          nodeType: isDocType ? \"doctype\" : \"tag\",\n          value: isSC ? trim(token.slice(0, -1)) : trim(token),\n          isSC,\n        });\n      }\n      token = \"\";\n      inTag = false;\n    } else {\n      token += fromCharCode(char);\n    }\n  }\n\n  trim(token) &&\n    tokens.push({ nodeType: \"text\", value: trim(token), isSC: false });\n\n  return tokens;\n};\n\nexport const DOM_ERROR = \"DomParserError:\";\n","import {\n  getBaseAttributes,\n  selfClosingTags,\n  tokenize,\n  toUpperCase,\n} from \"./util.ts\";\nimport type {\n  CommentLike,\n  NodeLike,\n  ParseResult,\n  RootLike,\n  TextLike,\n} from \"./types\";\n\n/**\n * **Parser**\n *\n * A tiny yet very fast and powerful parser that takes a string of HTML\n * and returns a DOM tree representation.\n *\n * The DOM representation is a plain object with the following structure:\n * ```ts\n *  type CommentLike = {\n *   nodeName: \"#comment\";\n *   nodeValue: string;\n *  };\n *  type TextLike = {\n *   nodeName: \"#text\";\n *   nodeValue: string;\n *  };\n *  type NodeLike = {\n *   tagName: string;\n *   nodeName: string;\n *   attributes: Record<string, string>;\n *   children: NodeLike[];\n *  };\n *  // the root node\n *  type RootLike = {\n *   nodeName: string;\n *   doctype?: string;\n *   children: NodeLike[];\n * };\n * ```\n *\n * @example\n * ```ts\n * const { root, components, tags } = Parser().parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a RootLike node,\n * // > \"components\" is an array of component names,\n * // > \"tags\" is an array of tag names.\n * ```\n *\n * @returns The result of the parser.\n */\nexport function Parser() {\n  return {\n    parseFromString(htmlString?: string): ParseResult {\n      const root: RootLike = { nodeName: \"#document\", children: [] };\n      if (!htmlString) return { root, tags: [], components: [] };\n\n      const stack: (RootLike | NodeLike)[] = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n\n      tokenize(htmlString).forEach((token) => {\n        const { nodeType, value, isSC } = token;\n        const currentParent = stack[stack.length - 1];\n        if (nodeType === \"doctype\") return;\n\n        if ([\"text\", \"comment\"].includes(nodeType)) {\n          currentParent.children.push(\n            {\n              nodeName: `#${nodeType}`,\n              nodeValue: value,\n            } as CommentLike | TextLike,\n          );\n          return;\n        }\n\n        const isClosing = value.startsWith(\"/\");\n        const tagName =\n          (isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0]) as NodeLike[\n            \"tagName\"\n          ];\n        const isSelfClosing = isSC ||\n          selfClosingTags.has(tagName);\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) ||\n            tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node: NodeLike = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getBaseAttributes(value),\n            children: [],\n          };\n\n          currentParent.children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      });\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      };\n    },\n  };\n}\n"]}