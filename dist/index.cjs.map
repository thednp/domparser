{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["export type ParserOptions = {\n  filterTags?: string[];\n  filterAttrs?: string[];\n};\n\nexport type RootNode = {\n  nodeName: string;\n  children: DOMLike[];\n};\n\nexport type DOMLike = {\n  tagName?: string;\n  nodeName: string;\n  attributes: Record<string, string>;\n  children: DOMLike[];\n  nodeValue?: string;\n};\n\nexport type ParseResult = {\n  root: RootNode;\n  components: string[];\n  tags: string[];\n};\n\nexport type HTMLToken = {\n  nodeType: string;\n  value: string;\n  isSC?: boolean;\n};\n\nconst toLowerCase = (str: string): string => str.toLowerCase();\nconst toUpperCase = (str: string): string => str.toUpperCase();\nconst startsWith = (str: string, prefix: string): boolean =>\n  str.startsWith(prefix);\nconst endsWith = (str: string, suffix: string): boolean => str.endsWith(suffix);\nconst charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * A basic tool for HTML entities encoding\n * @param str the source string\n * @returns the encoded string\n */\nexport const encodeEntities = (str: string): string =>\n  str.replace(/[&<>\"']/g, (char) => ({\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n  }[char] || /* istanbul ignore next @preserve */ char));\n\n/**\n * Sanitizes URLs in attribute values\n * @param url the URL\n * @returns the sanitized URL\n */\nexport const sanitizeUrl = (url: string): string => {\n  const decoded = decodeURIComponent(url.trim());\n  if (/^(?:javascript|data|vbscript):/i.test(decoded)) return \"\";\n  return encodeEntities(decoded);\n};\n\n/**\n * Sanitizes attribute values\n * @param name the attribute name\n * @param initialValue the attribute value\n * @returns the sanitized value\n */\nexport const sanitizeAttrValue = (\n  name: string,\n  initialValue: string,\n): string => {\n  if (!initialValue) return \"\";\n  const value = initialValue.trim();\n\n  // Special handling for URL attributes\n  if (\n    name === \"src\" || name === \"href\" || name === \"action\" ||\n    name === \"formaction\" || endsWith(name, \"url\")\n  ) {\n    return sanitizeUrl(value);\n  }\n\n  return encodeEntities(value);\n};\n\n/**\n * Get attributes from a string token and return an object\n * where the keys are the names of the attributes and the values\n * are the sanitized values of the attributes.\n *\n * @param tagStr the tring token\n * @param unsafeAttrs an optional set of unsafe attributes\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  unsafeAttrs: Set<string> = new Set(),\n): Record<string, string> => {\n  const attrs: Record<string, string> = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: unknown;\n  const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n  while ((match = attrRegex.exec(attrStr))) {\n    const [, name, d, s, u] = match as RegExpMatchArray;\n    if (name && name !== \"/\" && !unsafeAttrs.has(toLowerCase(name))) {\n      attrs[name] = sanitizeAttrValue(toLowerCase(name), d ?? s ?? u ?? \"\");\n    }\n  }\n\n  return attrs;\n};\n\nconst rootNode: RootNode = {\n  nodeName: \"#document\",\n  children: [],\n};\n\n/**\n * **DOMParser**\n *\n * A tiny yet very fast and powerful HTML parser that\n * takes a string of HTML and returns a simple DOM representation.\n *\n * **Features**\n * * The parser is around 1.2Kb and is optimized for speed and memory efficiency.\n * * The parser handles basic HTML elements, custom elements,\n * UI frameworks components, special attributes, and text nodes.\n * * The parser provides basic sanitization for specific attributes\n * and options to filter tags and attributes; _by default the filters are empty_.\n * * You can also make use of its sanitization tools in your own application.\n * * Fully tested with Vitest.\n *\n * The DOM representation is a plain object with the following structure:\n * ```ts\n *  type DOMLike = {\n *   tagName?: string; // applied only to Element nodes\n *   nodeName: string;\n *   attributes: Record<string, string>;\n *   children: DOMLike[];\n *   value?: string; // applied only to #text nodes\n * };\n * ```\n *\n * @example\n * ```ts\n * const config = {\n *   // Common dangerous tags that could lead to XSS\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const parser = Parser(config);\n * const { root, components, tags } = parser.parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a DOMLike node, \"components\" is an array of component names, \"tags\" is an array of tag names\n * ```\n *\n * @param config an optional configuration object\n * @returns the parsed result\n */\nexport function Parser(config: Partial<ParserOptions> = {}) {\n  const selfClosingTags = new Set([\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n    \"path\",\n    \"circle\",\n    \"ellipse\",\n    \"line\",\n    \"rect\",\n    \"use\",\n    \"stop\",\n    \"polygon\",\n    \"polyline\",\n  ]);\n\n  // Common dangerous tags that could lead to XSS\n  const unsafeTags = new Set<string>();\n\n  // Unsafe attributes that could lead to XSS\n  const unsafeAttrs = new Set<string>();\n\n  // Apply config\n  /* istanbul ignore else @preserve */\n  if (config) {\n    const { filterTags, filterAttrs } = config;\n    if (filterTags) filterTags.forEach((tag) => unsafeTags.add(tag));\n    if (filterAttrs) filterAttrs.forEach((attr) => unsafeAttrs.add(attr));\n  }\n\n  const tokenize = (html: string): HTMLToken[] => {\n    const tokens: HTMLToken[] = [];\n    let token = \"\",\n      inTag = false,\n      inQuote = false,\n      quote = 0,\n      isComment = false;\n\n    for (let i = 0; i < html.length; i++) {\n      const char = charCodeAt(html, i);\n\n      if (isComment) {\n        token += String.fromCharCode(char);\n        if (endsWith(token, \"--\")) {\n          /* istanbul ignore else @preserve */\n          if (charCodeAt(html, i + 1) === 62 /* > */) {\n            tokens.push({\n              nodeType: \"comment\",\n              value: token.trim(),\n              isSC: false,\n            });\n            token = \"\";\n            isComment = false;\n            i++;\n          }\n        }\n        continue;\n      }\n\n      if (inTag && (char === 34 || char === 39)) { // \" or ' | 0x22 or 0x27\n        if (!inQuote) {\n          quote = char;\n          inQuote = true;\n        } else if (char === quote) inQuote = false;\n        token += String.fromCharCode(char);\n        continue;\n      }\n\n      if (char === 60 /* 0x3c */ && !inQuote) { // <\n        token.trim() && tokens.push({\n          nodeType: \"text\",\n          value: encodeEntities(token.trim()),\n          isSC: false,\n        });\n        token = \"\";\n        inTag = true;\n        if (\n          charCodeAt(html, i + 1) === 33 /* ! | 0x21 */ &&\n          charCodeAt(html, i + 2) === 45 /* - | 0x2d */ &&\n          charCodeAt(html, i + 3) === 45 /* - | 0x2d */\n        ) {\n          isComment = true;\n          token += \"!--\";\n          i += 3;\n          continue;\n        }\n      } else if (char === 62 /* 0x3e */ && !inQuote && inTag && !isComment) { // > | 0x3e\n        /* istanbul ignore else @preserve */\n        if (token) {\n          const isSC = endsWith(token, \"/\");\n          const isDocType = startsWith(token, \"!doctype\");\n          // console.log({ token, isDocType });\n          tokens.push({\n            nodeType: isDocType ? \"doctype\" : \"tag\",\n            value: isSC ? token.slice(0, -1).trim() : token.trim(),\n            isSC,\n          });\n        }\n        token = \"\";\n        inTag = false;\n      } else {\n        token += String.fromCharCode(char);\n      }\n    }\n\n    token.trim() && tokens.push({\n      nodeType: \"text\",\n      value: encodeEntities(token.trim()),\n      isSC: false,\n    });\n    return tokens;\n  };\n\n  return {\n    parseFromString(htmlString?: string) {\n      const root: RootNode = { ...rootNode, children: [] };\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      let parentIsSafe = true;\n\n      tokenize(htmlString).forEach((token) => {\n        const { nodeType, value, isSC } = token;\n        // Skip doctype, we already have a root\n        if (nodeType === \"doctype\") return;\n\n        if ([\"text\", \"comment\"].includes(nodeType)) {\n          stack[stack.length - 1].children.push({\n            nodeName: `#${nodeType}`,\n            nodeValue: nodeType === \"text\" ? value : `<${value}>`,\n          } as DOMLike);\n          return;\n        }\n\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC || selfClosingTags.has(tagNameLower);\n\n        // Skip unsafe tags\n        if (unsafeTags.has(tagNameLower)) {\n          if (isClosing) {\n            parentIsSafe = true;\n          } else {\n            parentIsSafe = false;\n          }\n          return;\n        }\n\n        if (!parentIsSafe) return;\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getAttributes(value, unsafeAttrs),\n            children: [],\n          };\n\n          stack[stack.length - 1].children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      });\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies ParseResult;\n    },\n  };\n}\n"],"names":["toLowerCase","str","toUpperCase","startsWith","prefix","endsWith","suffix","charCodeAt","index","encodeEntities","char","sanitizeUrl","url","decoded","sanitizeAttrValue","name","initialValue","value","getAttributes","tagStr","unsafeAttrs","attrs","parts","attrStr","match","attrRegex","d","s","rootNode","Parser","config","selfClosingTags","unsafeTags","filterTags","filterAttrs","tag","attr","tokenize","html","tokens","token","inTag","inQuote","quote","isComment","isSC","isDocType","htmlString","root","stack","components","tags","parentIsSafe","nodeType","isClosing","tagName","tagNameLower","isSelfClosing","node"],"mappings":"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"}