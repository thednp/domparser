{"version":3,"sources":["../src/parts/parser.ts","../src/parts/util.ts"],"sourcesContent":["// parser.ts\nimport {\n  getBaseAttributes,\n  selfClosingTags,\n  tokenize,\n  toLowerCase,\n  toUpperCase,\n} from \"./util.ts\";\nimport type {\n  CommentLike,\n  NodeLike,\n  ParseResult,\n  RootLike,\n  TextLike,\n} from \"./types\";\n\n/**\n * **Parser**\n *\n * A tiny yet very fast and powerful parser that takes a string of HTML\n * and returns a DOM tree representation. In benchmarks it shows up to\n * 60x faster performance when compared to jsdom.\n *\n * @example\n * ```ts\n * const { root, components, tags } = Parser().parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a RootLike node,\n * // > \"components\" is an array of component names,\n * // > \"tags\" is an array of tag names.\n * ```\n *\n * @returns The result of the parser.\n */\nexport function Parser() {\n  return {\n    parseFromString(htmlString?: string): ParseResult {\n      const root: RootLike = { nodeName: \"#document\", children: [] };\n      if (!htmlString) return { root, tags: [], components: [] };\n\n      const stack: (RootLike | NodeLike)[] = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      const tokens = tokenize(htmlString);\n      const tLen = tokens.length;\n\n      for (let i = 0; i < tLen; i += 1) {\n        const { tokenType, value, isSC } = tokens[i];\n        const currentParent = stack[stack.length - 1];\n        if (tokenType === \"doctype\") continue;\n\n        if ([\"text\", \"comment\"].includes(tokenType)) {\n          currentParent.children.push(\n            {\n              nodeName: `#${tokenType}`,\n              nodeValue: value,\n            } as CommentLike | TextLike,\n          );\n          continue;\n        }\n\n        const isClosing = value.startsWith(\"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC ||\n          selfClosingTags.has(tagNameLower);\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) ||\n            tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node: NodeLike = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getBaseAttributes(value),\n            children: [],\n          };\n\n          currentParent.children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      };\n    },\n  };\n}\n","// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  GetAttributesOptions,\n  HTMLToken,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n  TokenizerOptions,\n} from \"./types.ts\";\n\n// general utils\n\nexport const ATTR_REGEX = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n/**\n * Get attributes from a string token and return an object\n * @param tagStr the string token\n * @returns the attributes object\n */\nexport const getBaseAttributes = (tagStr: string) => {\n  const attrs: NodeLikeAttributes = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: RegExpExecArray | null;\n\n  while ((match = ATTR_REGEX.exec(attrStr))) {\n    const [, name, d, s, u] = match;\n    name !== \"/\" && (attrs[name] = d ?? s ?? u ?? \"\");\n  }\n\n  return attrs;\n};\n\n/**\n * Get attributes from a string token and return an object.\n * In addition to the base tool, this also filters configured\n * unsafe attributes.\n * @param tagStr the string token\n * @param config an optional set of options\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  config?: Partial<GetAttributesOptions>,\n): NodeLikeAttributes => {\n  const { unsafeAttrs } = config || {};\n  const baseAttrs = getBaseAttributes(tagStr);\n  const attrs: NodeLikeAttributes = {};\n\n  for (const [key, value] of Object.entries(baseAttrs)) {\n    if (!unsafeAttrs || !unsafeAttrs?.has(toLowerCase(key))) {\n      attrs[key] = value;\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (\n  str: string,\n  prefix: string,\n  position?: number,\n): boolean => str.startsWith(prefix, position);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (\n  str: string,\n  suffix: string,\n  position?: number,\n): boolean => str.endsWith(suffix, position);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Trim a string value.\n * @param str A string value\n * @returns The trimmed value of the same string.\n */\nexport const trim = (str: string) => str.trim();\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"?xml\",\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\nexport const escape = (str: string) => {\n  if ((str === null) || (str === \"\")) {\n    return false;\n  } else {\n    str = str.toString();\n  }\n\n  const map: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#039;\",\n  };\n\n  return str.replace(/[&<>\"']/g, (m) => {\n    return map[m];\n  });\n};\n\nexport const DOM_ERROR = \"DomParserError:\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024; // 65536 = 64KB\nconst DEFAULT_MAX_SCRIPT_SIZE = 128 * 1024; // 131072 = 128KB\n\n/**\n * Tokenizes an HTML string into an array of HTML tokens.\n * These tokens represent opening tags, closing tags, text content, and comments.\n * @param html The HTML string to tokenize.\n * @returns An array of `HTMLToken` objects.\n */\n\nexport const tokenize = (\n  html: string,\n  options: TokenizerOptions = {},\n): HTMLToken[] => {\n  const {\n    maxScriptSize = DEFAULT_MAX_SCRIPT_SIZE,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  } = options;\n\n  const specialTags = [\"script\", \"style\"] as const;\n  const tokens: HTMLToken[] = [];\n  const len = html.length;\n\n  let token = \"\";\n  let scriptContent = \"\";\n  let inTag = false;\n  let inQuote = false;\n  let quote = 0;\n  let inTemplate = false;\n  let inComment = false;\n  let inCDATA = false;\n  let inStyleScript = false;\n  let currentChunkStart = 0;\n\n  while (currentChunkStart < len) {\n    const chunkEnd = Math.min(currentChunkStart + chunkSize, len);\n    const chunk = html.slice(currentChunkStart, chunkEnd);\n\n    for (let i = 0; i < chunk.length; i++) {\n      const globalIndex = currentChunkStart + i;\n      const char = charCodeAt(chunk, i);\n\n      if (inStyleScript) {\n        const endSpecialTag = specialTags.find((t) =>\n          startsWith(html, `/${t}`, globalIndex + 1)\n        );\n\n        if (char === 60 && endSpecialTag && !inTemplate && !inQuote) { // <\n          // istanbul ignore else @preserve\n          if (scriptContent.length < maxScriptSize) {\n            tokens.push({\n              tokenType: \"text\",\n              value: trim(scriptContent),\n              isSC: false,\n            });\n          }\n          tokens.push({\n            tokenType: \"tag\",\n            value: \"/\" + endSpecialTag,\n            isSC: false,\n          });\n          scriptContent = \"\";\n          inStyleScript = false;\n          i += endSpecialTag.length + 2;\n        } else {\n          // istanbul ignore next @preserve - don't crash the test!!\n          if (scriptContent.length >= maxScriptSize) {\n            // Once we hit the limit, just skip content until closing tag\n            continue;\n          }\n          if (char === 96) {\n            inTemplate = !inTemplate;\n          } else if (!inTemplate && (char === 34 || char === 39)) {\n            // istanbul ignore else @preserve\n            if (!inQuote) {\n              quote = char;\n              inQuote = true;\n            } else if (char === quote) {\n              inQuote = false;\n            }\n          }\n          scriptContent += fromCharCode(char);\n        }\n        continue;\n      }\n\n      if (inComment) {\n        token += fromCharCode(char);\n        if (endsWith(token, \"--\") && charCodeAt(html, globalIndex + 1) === 62) {\n          tokens.push({\n            tokenType: \"comment\",\n            value: `<${trim(token)}>`,\n            isSC: false,\n          });\n          inComment = false;\n          token = \"\";\n          i += 1;\n        }\n        continue;\n      }\n\n      if (inCDATA) {\n        token += fromCharCode(char);\n        if (endsWith(token, \"]]\") && charCodeAt(html, globalIndex + 1) === 62) {\n          tokens.push({\n            tokenType: \"text\",\n            value: `<${escape(trim(token))}>`,\n            isSC: false,\n          });\n          inCDATA = false;\n          token = \"\";\n          i += 1;\n        }\n        continue;\n      }\n\n      if (\n        (inTag && token.includes(\"=\") || inStyleScript) &&\n        (char === 34 || char === 39)\n      ) {\n        if (!inQuote) {\n          quote = char;\n          inQuote = true;\n        } else if (char === quote) {\n          inQuote = false;\n        }\n        token += fromCharCode(char);\n        continue;\n      }\n\n      if (char === 60 && !inQuote && !inTemplate && !inStyleScript) {\n        trim(token) &&\n          tokens.push({\n            tokenType: \"text\",\n            value: trim(token),\n            isSC: false,\n          });\n        token = \"\";\n        inTag = true;\n\n        if (startsWith(chunk, \"!--\", i + 1)) {\n          inComment = true;\n          token += \"!--\";\n          i += 3;\n          continue;\n        }\n        if (startsWith(chunk, \"![CDATA[\", i + 1)) {\n          inCDATA = true;\n          token += \"![CDATA[\";\n          i += 8;\n          continue;\n        }\n      } else if (\n        char === 62 && inTag && !inTemplate && !inComment &&\n        !inStyleScript && !inCDATA\n      ) {\n        const startSpecialTag = specialTags.find((t) =>\n          t === token || startsWith(token, t)\n        );\n        if (startSpecialTag && !endsWith(token, \"/\")) {\n          inStyleScript = true;\n        }\n\n        const isDocType = startsWith(toLowerCase(token), \"!doctype\");\n\n        // istanbul ignore else @preserve\n        if (token) {\n          const isSC = endsWith(token, \"/\");\n          const [tagName] = token.split(/\\s/);\n          const value = inQuote ? tagName + (isSC ? \"/\" : \"\") : token;\n          tokens.push({\n            tokenType: isDocType ? \"doctype\" : \"tag\",\n            value: isSC ? trim(value.slice(0, -1)) : trim(value),\n            isSC,\n          });\n        }\n        token = \"\";\n        inTag = false;\n        inQuote = false;\n      } else {\n        token += fromCharCode(char);\n      }\n    }\n    currentChunkStart = chunkEnd;\n  }\n\n  const lastToken = trim(token);\n  if (lastToken) {\n    tokens.push({\n      tokenType: \"text\",\n      value: lastToken,\n      isSC: false,\n    });\n  }\n\n  return tokens;\n};\n"],"mappings":"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","names":[]}