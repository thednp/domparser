{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import type { DOMNode, HTMLToken, ParseResult } from \"./types\";\n\n/** A full list of self-closing tags */\nconst selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\n/**\n * Returns a quoted string if the key is a valid identifier,\n * otherwise returns the original key.\n * @param key\n * @returns\n */\nconst quoteText = (key: string) =>\n  /^[a-zA-Z_][a-zA-Z_0-9]+$/.test(key) ? key : `\"${key}\"`;\n\n/**\n * A basic HTML parser that takes a string of HTML and returns a simple DOM representation.\n * The parser handles basic HTML elements, attributes, and text content.\n * The DOM representation is a plain object with the following structure:\n * ```\n * {\n *     tagName?: string,\n *     nodeName: string,\n *     attributes: {\n *         [key: string]: string\n *     },\n *     children: [\n *         {\n *             tagName?: string,\n *             attributes: {\n *                 [key: string]: string\n *             },\n *             children: [...],\n *             value: string\n *         }\n *     ]\n * }\n * ```\n */\nexport default class DOMParser {\n  static selfClosingTags = selfClosingTags;\n  static quoteText = quoteText;\n  tags = new Set<string>();\n  components = new Set<string>();\n  root: DOMNode = { nodeName: \"#document\", attributes: {}, children: [] };\n  stack: Array<DOMNode> = [this.root];\n  currentNode: DOMNode = this.root;\n\n  /**\n   * Returns a simple DOM representation of the parsed HTML.\n   * @param htmlString The string of HTML to be parsed.\n   * @return the parsed result.\n   */\n  parseFromString(htmlString: string): ParseResult {\n    const tokens = this.tokenize(htmlString);\n    this.parseTokens(tokens);\n    const root = this.root;\n    return {\n      root,\n      components: Array.from(this.components),\n      tags: Array.from(this.tags),\n    };\n  }\n\n  /**\n   * Parse a string of HTML and return an array of tokens\n   * where each token is an object with a type property and a value property.\n   *\n   * @param htmlString The string of HTML to be tokenized.\n   * @return The array of tokens.\n   */\n  tokenize(htmlString: string): Array<HTMLToken> {\n    const tokens = [];\n    let currentToken = \"\";\n    let inTag = false;\n    let inQuote = false;\n    let quoteChar = 0x22;\n\n    for (let i = 0; i < htmlString.length; i++) {\n      const charCode = htmlString.charCodeAt(i);\n\n      // Handle quotes inside tags\n      if (inTag && (charCode === 0x22 /* \" */ || charCode === 0x27 /* ' */)) {\n        /* istanbul ignore else @preserve */\n        if (!inQuote) {\n          inQuote = true;\n          quoteChar = charCode;\n        } else if (charCode === quoteChar) {\n          inQuote = false;\n        }\n        currentToken += String.fromCharCode(charCode);\n        continue;\n      }\n\n      if (charCode === 0x3c /* < */ && !inQuote) {\n        if (currentToken.trim()) {\n          tokens.push({ type: \"text\", value: currentToken.trim() });\n        }\n        currentToken = \"\";\n        inTag = true;\n      } else if (charCode === 0x3e /* > */ && !inQuote) {\n        /* istanbul ignore else @preserve */\n        if (currentToken) {\n          // Check if it's a self-closing tag\n          const isSelfClosing = currentToken.endsWith(\"/\");\n          if (isSelfClosing) {\n            currentToken = currentToken.slice(0, -1);\n          }\n          tokens.push({\n            type: \"tag\",\n            value: currentToken.trim(),\n            isSelfClosing,\n          });\n        }\n        currentToken = \"\";\n        inTag = false;\n      } else {\n        currentToken += String.fromCharCode(charCode);\n      }\n    }\n\n    /* istanbul ignore if @preserve */\n    if (currentToken.trim()) {\n      tokens.push({\n        type: \"text\",\n        value: currentToken.trim(),\n        isSelfClosing: false,\n      });\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Parse an array of tokens into a DOM representation.\n   * @param tokens An array of tokens to be parsed.\n   */\n  parseTokens(tokens: Array<HTMLToken>) {\n    // reset parser state\n    this.root = { nodeName: \"#document\", attributes: {}, children: [] };\n    this.stack = [this.root];\n    this.currentNode = this.root;\n\n    // iterate over tokens\n    for (const token of tokens) {\n      let tagName = this.getTagName(token.value);\n      const isClosingTag = token.value.startsWith(\"/\");\n      const isSelfClosing = token.isSelfClosing;\n\n      tagName = isClosingTag\n        ? token.value.slice(1)\n        : this.getTagName(token.value);\n\n      /* istanbul ignore else @preserve */\n      if (token.type === \"tag\") {\n        tagName = tagName.replace(/\\/$/, \"\"); // Remove trailing slash for self-closing tags\n        const isComponent = tagName[0].toUpperCase() === tagName[0] ||\n          tagName.includes(\"-\");\n\n        if (isComponent) {\n          this.components.add(tagName);\n        } else {\n          this.tags.add(tagName);\n        }\n\n        if (!isClosingTag) {\n          const newNode = {\n            tagName,\n            nodeName: tagName.toUpperCase(),\n            attributes: isSelfClosing ? {} : this.getAttributes(token.value),\n            isSelfClosing,\n            children: [],\n          };\n\n          if (isSelfClosing) {\n            // Handle self-closing tag\n            this.currentNode.children.push(newNode);\n            // Don't push to stack since self-closing tags don't wrap content\n          } else {\n            this.currentNode.children.push(newNode);\n            this.stack.push(newNode);\n            this.currentNode = newNode;\n          }\n        } else {\n          this.stack.pop();\n          /* istanbul ignore else @preserve */\n          if (this.stack.length > 0) {\n            this.currentNode = this.stack[this.stack.length - 1];\n          }\n        }\n      } else if (token.type === \"text\") {\n        const textNode = {\n          nodeName: \"#text\",\n          attributes: {},\n          children: [],\n          value: token.value,\n        };\n        this.currentNode.children.push(textNode);\n      }\n    }\n  }\n\n  /**\n   * Returns the name of the tag.\n   * @param tagString A string of HTML that represents a tag.\n   * @return The name of the tag.\n   */\n  getTagName(tagString: string): string {\n    return tagString.split(/[\\s/>]/)[0];\n  }\n\n  /**\n   * Returns an object where the keys are the names of the attributes\n   * and the values are the values of the attributes.\n   *\n   * @param tagString A string of HTML that represents a tag.\n   * @return an object where the keys are the names of the attributes and the values are the values of the attributes.\n   */\n  getAttributes(tagString: string): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n    const tagParts = tagString.split(/\\s+/);\n\n    if (tagParts.length < 2) return attributes;\n\n    const attrString = tagString.slice(tagParts[0].length);\n    let match;\n\n    while ((match = attrRegex.exec(attrString)) !== null) {\n      const [, name, doubleQuoted, singleQuoted, unquoted] = match;\n      /* istanbul ignore else @preserve */\n      if (name && name !== \"/\") {\n        attributes[name] = doubleQuoted ||\n          /* istanbul ignore next @preserve */ singleQuoted ||\n          /* istanbul ignore next @preserve */ unquoted ||\n          /* istanbul ignore next @preserve */ \"\";\n      }\n    }\n\n    return attributes;\n  }\n}\n"],"names":["selfClosingTags","quoteText","key","DOMParser","__publicField","htmlString","tokens","currentToken","inTag","inQuote","quoteChar","i","charCode","isSelfClosing","token","tagName","isClosingTag","newNode","textNode","tagString","attributes","attrRegex","tagParts","attrString","match","name","doubleQuoted","singleQuoted","unquoted"],"mappings":"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"}