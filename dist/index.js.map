{"version":3,"sources":["../src/index.ts","../src/parts/util.ts","../src/parts/selectors.ts","../src/parts/prototype.ts","../src/parts/parser.ts","../src/parts/dom-parser.ts"],"sourcesContent":["export * from \"./parts/util.ts\";\nexport * from \"./parts/types.ts\";\nexport * from \"./parts/prototype.ts\";\nexport { matchesSelector, selectorCache } from \"./parts/selectors.ts\";\nexport { Parser } from \"./parts/parser.ts\";\nexport { DomParser } from \"./parts/dom-parser.ts\";\n","// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  GetAttributesOptions,\n  HTMLToken,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n  TokenizerOptions,\n} from \"./types.ts\";\n\n// general utils\n\nexport const ATTR_REGEX = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n/**\n * Get attributes from a string token and return an object\n * @param tagStr the string token\n * @returns the attributes object\n */\nexport const getBaseAttributes = (tagStr: string) => {\n  const attrs: NodeLikeAttributes = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: RegExpExecArray | null;\n\n  while ((match = ATTR_REGEX.exec(attrStr))) {\n    const [, name, d, s, u] = match;\n    name !== \"/\" && (attrs[name] = d ?? s ?? u ?? \"\");\n  }\n\n  return attrs;\n};\n\n/**\n * Get attributes from a string token and return an object.\n * In addition to the base tool, this also filters configured\n * unsafe attributes.\n * @param tagStr the string token\n * @param config an optional set of options\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  config?: Partial<GetAttributesOptions>,\n): NodeLikeAttributes => {\n  const { unsafeAttrs } = config || {};\n  const baseAttrs = getBaseAttributes(tagStr);\n  const attrs: NodeLikeAttributes = {};\n\n  for (const [key, value] of Object.entries(baseAttrs)) {\n    if (!unsafeAttrs || !unsafeAttrs?.has(toLowerCase(key))) {\n      attrs[key] = value;\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (\n  str: string,\n  prefix: string,\n  position?: number,\n): boolean => str.startsWith(prefix, position);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (\n  str: string,\n  suffix: string,\n  position?: number,\n): boolean => str.endsWith(suffix, position);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Trim a string value.\n * @param str A string value\n * @returns The trimmed value of the same string.\n */\nexport const trim = (str: string) => str.trim();\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"?xml\",\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\nexport const escape = (str: string) => {\n  if ((str === null) || (str === \"\")) {\n    return false;\n  } else {\n    str = str.toString();\n  }\n\n  const map: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#039;\",\n  };\n\n  return str.replace(/[&<>\"']/g, (m) => {\n    return map[m];\n  });\n};\n\nexport const DOM_ERROR = \"DomParserError:\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024; // 65536 = 64KB\nconst DEFAULT_MAX_SCRIPT_SIZE = 128 * 1024; // 131072 = 128KB\n\n/**\n * Tokenizes an HTML string into an array of HTML tokens.\n * These tokens represent opening tags, closing tags, text content, and comments.\n * @param html The HTML string to tokenize.\n * @returns An array of `HTMLToken` objects.\n */\n\nexport const tokenize = (\n  html: string,\n  options: TokenizerOptions = {},\n): HTMLToken[] => {\n  const {\n    maxScriptSize = DEFAULT_MAX_SCRIPT_SIZE,\n    chunkSize = DEFAULT_CHUNK_SIZE,\n  } = options;\n\n  const specialTags = [\"script\", \"style\"] as const;\n  const tokens: HTMLToken[] = [];\n  const len = html.length;\n\n  let token = \"\";\n  let scriptContent = \"\";\n  let inTag = false;\n  let inQuote = false;\n  let quote = 0;\n  let inTemplate = false;\n  let inComment = false;\n  let inCDATA = false;\n  let inStyleScript = false;\n  let currentChunkStart = 0;\n\n  while (currentChunkStart < len) {\n    const chunkEnd = Math.min(currentChunkStart + chunkSize, len);\n    const chunk = html.slice(currentChunkStart, chunkEnd);\n\n    for (let i = 0; i < chunk.length; i++) {\n      const globalIndex = currentChunkStart + i;\n      const char = charCodeAt(chunk, i);\n\n      if (inStyleScript) {\n        const endSpecialTag = specialTags.find((t) =>\n          startsWith(html, `/${t}`, globalIndex + 1)\n        );\n\n        if (char === 60 && endSpecialTag && !inTemplate && !inQuote) { // <\n          // istanbul ignore else @preserve\n          if (scriptContent.length < maxScriptSize) {\n            tokens.push({\n              tokenType: \"text\",\n              value: trim(scriptContent),\n              isSC: false,\n            });\n          }\n          tokens.push({\n            tokenType: \"tag\",\n            value: \"/\" + endSpecialTag,\n            isSC: false,\n          });\n          scriptContent = \"\";\n          inStyleScript = false;\n          i += endSpecialTag.length + 2;\n        } else {\n          // istanbul ignore next @preserve - don't crash the test!!\n          if (scriptContent.length >= maxScriptSize) {\n            // Once we hit the limit, just skip content until closing tag\n            continue;\n          }\n          if (char === 96) {\n            inTemplate = !inTemplate;\n          } else if (!inTemplate && (char === 34 || char === 39)) {\n            // istanbul ignore else @preserve\n            if (!inQuote) {\n              quote = char;\n              inQuote = true;\n            } else if (char === quote) {\n              inQuote = false;\n            }\n          }\n          scriptContent += fromCharCode(char);\n        }\n        continue;\n      }\n\n      if (inComment) {\n        token += fromCharCode(char);\n        if (endsWith(token, \"--\") && charCodeAt(html, globalIndex + 1) === 62) {\n          tokens.push({\n            tokenType: \"comment\",\n            value: `<${trim(token)}>`,\n            isSC: false,\n          });\n          inComment = false;\n          token = \"\";\n          i += 1;\n        }\n        continue;\n      }\n\n      if (inCDATA) {\n        token += fromCharCode(char);\n        if (endsWith(token, \"]]\") && charCodeAt(html, globalIndex + 1) === 62) {\n          tokens.push({\n            tokenType: \"text\",\n            value: `<${escape(trim(token))}>`,\n            isSC: false,\n          });\n          inCDATA = false;\n          token = \"\";\n          i += 1;\n        }\n        continue;\n      }\n\n      if (\n        (inTag && token.includes(\"=\") || inStyleScript) &&\n        (char === 34 || char === 39)\n      ) {\n        if (!inQuote) {\n          quote = char;\n          inQuote = true;\n        } else if (char === quote) {\n          inQuote = false;\n        }\n        token += fromCharCode(char);\n        continue;\n      }\n\n      if (char === 60 && !inQuote && !inTemplate && !inStyleScript) {\n        trim(token) &&\n          tokens.push({\n            tokenType: \"text\",\n            value: trim(token),\n            isSC: false,\n          });\n        token = \"\";\n        inTag = true;\n\n        if (startsWith(chunk, \"!--\", i + 1)) {\n          inComment = true;\n          token += \"!--\";\n          i += 3;\n          continue;\n        }\n        if (startsWith(chunk, \"![CDATA[\", i + 1)) {\n          inCDATA = true;\n          token += \"![CDATA[\";\n          i += 8;\n          continue;\n        }\n      } else if (\n        char === 62 && inTag && !inTemplate && !inComment &&\n        !inStyleScript && !inCDATA\n      ) {\n        const startSpecialTag = specialTags.find((t) =>\n          t === token || startsWith(token, t)\n        );\n        if (startSpecialTag && !endsWith(token, \"/\")) {\n          inStyleScript = true;\n        }\n\n        const isDocType = startsWith(toLowerCase(token), \"!doctype\");\n\n        // istanbul ignore else @preserve\n        if (token) {\n          const isSC = endsWith(token, \"/\");\n          const [tagName] = token.split(/\\s/);\n          const value = inQuote ? tagName + (isSC ? \"/\" : \"\") : token;\n          tokens.push({\n            tokenType: isDocType ? \"doctype\" : \"tag\",\n            value: isSC ? trim(value.slice(0, -1)) : trim(value),\n            isSC,\n          });\n        }\n        token = \"\";\n        inTag = false;\n        inQuote = false;\n      } else {\n        token += fromCharCode(char);\n      }\n    }\n    currentChunkStart = chunkEnd;\n  }\n\n  const lastToken = trim(token);\n  if (lastToken) {\n    tokens.push({\n      tokenType: \"text\",\n      value: lastToken,\n      isSC: false,\n    });\n  }\n\n  return tokens;\n};\n","// selectors.ts\nimport { startsWith, toLowerCase } from \"./util.ts\";\nimport type { DOMNode, MatchFunction, SelectorPart } from \"./types.ts\";\n\n/**\n * Create a selector cache to help improve `match` based queries\n * (matches, querySelector, querySelectorAll).\n */\nclass SelectorCacheMap extends Map<string, MatchFunction> {\n  private hits = 0;\n  private misses = 0;\n\n  constructor() {\n    super();\n    this.misses = 0;\n    this.hits = 0;\n  }\n  hit() {\n    this.hits += 1;\n  }\n  miss() {\n    this.hits += 1;\n  }\n  getMatchFunction(selector: string, maxSize = 100): MatchFunction {\n    let matchFn = this.get(selector);\n\n    if (!matchFn) {\n      this.miss();\n      // If cache is full, remove oldest entry\n      if (this.size >= maxSize) {\n        const firstKey = this.keys().next().value;\n        /* istanbul ignore else @preserve */\n        if (firstKey) this.delete(firstKey);\n      }\n\n      // Parse selector parts once and create a matcher function\n      const parts = selector.split(\",\").map((s) => s.trim());\n\n      matchFn = (node: DOMNode): boolean =>\n        parts.some((part) => matchesSingleSelector(node, part));\n\n      this.set(selector, matchFn);\n    } else {\n      this.hit();\n    }\n\n    return matchFn;\n  }\n  clear() {\n    super.clear();\n    this.misses = 0;\n    this.hits = 0;\n  }\n  getStats() {\n    return {\n      size: this.size,\n      hits: this.hits,\n      misses: this.misses,\n      // prevent division by ZERO\n      hitRate: this.hits / ((this.hits + this.misses) || 1),\n    };\n  }\n}\n\nexport const selectorCache = new SelectorCacheMap();\n\n// Selector RegExp\nconst SELECTOR_REGEX = /([.#]?[\\w-]+|\\[[\\w-]+(?:=[^\\]]+)?\\])+/g;\n\n/**\n * Parses a CSS selector string into an array of selector parts.\n * Each part represents a segment of the selector (e.g., tag name, class, id, attribute).\n * @param selector The CSS selector string to parse.\n * @returns An array of `SelectorPart` objects representing the parsed selector.\n */\nconst parseSelector = (selector: string): SelectorPart[] => {\n  const parts: SelectorPart[] = [];\n  const matches =\n    selector.match(SELECTOR_REGEX) || /* istanbul ignore next @preserve */ [];\n\n  for (const match of matches) {\n    if (startsWith(match, \"#\")) {\n      parts.push({ type: \"#\", name: \"id\", value: match.slice(1) });\n    } else if (startsWith(match, \".\")) {\n      parts.push({ type: \".\", name: \"class\", value: match.slice(1) });\n    } else if (startsWith(match, \"[\")) {\n      const [name, value] = match.slice(1, -1).split(\"=\");\n      parts.push({\n        type: \"[\",\n        name,\n        value: value ? value.replace(/['\"]/g, \"\") : undefined,\n      });\n    } else {\n      parts.push({ type: \"\", name: match });\n    }\n  }\n  return parts;\n};\n\n/**\n * Checks if a node matches a single CSS selector.\n * @param node The `DOMNode` object to test against the selector.\n * @param selector The CSS selector string.\n * @returns `true` if the node matches the selector, `false` otherwise.\n */\nconst matchesSingleSelector = (node: DOMNode, selector: string): boolean => {\n  const parts = parseSelector(selector);\n\n  return parts.every((part) => {\n    switch (part.type) {\n      case \"#\": {\n        return node.attributes.get(\"id\") === part.value;\n      }\n      case \".\": {\n        const classes = node.attributes.get(\"class\")?.split(/\\s+/) || [];\n        return classes.includes(part.value as string);\n      }\n      case \"[\": {\n        const attrValue = node.attributes.get(part.name);\n        return part.value ? attrValue === part.value : attrValue !== undefined;\n      }\n      default: {\n        return toLowerCase(node.tagName) === toLowerCase(part.name);\n      }\n    }\n  });\n};\n\n/**\n * Checks if a node matches one or mode CSS selectors.\n * @param node The `DOMNode` object to test against the selector.\n * @param selector The CSS selector string.\n * @returns `true` if the node matches the selector, `false` otherwise.\n */\nexport const matchesSelector = (node: DOMNode, selector: string): boolean => {\n  const matcher = selectorCache.getMatchFunction(selector);\n  return matcher(node);\n};\n","// prototype.ts\nimport { tokenize } from \"./util.ts\";\nimport { matchesSelector } from \"./selectors.ts\";\nimport {\n  defineProperties,\n  DOM_ERROR,\n  isNode,\n  isObj,\n  isPrimitive,\n  isRoot,\n  isTag,\n  selfClosingTags,\n  toUpperCase,\n} from \"./util.ts\";\n\nimport type {\n  ChildElementList,\n  ChildNode,\n  ChildNodeList,\n  CommentNode,\n  DOMNode,\n  MaybeChildNode,\n  NodeLikeAttributes,\n  RootNode,\n  TagNames,\n  TextNode,\n  TextToken,\n} from \"./types.ts\";\n\n/**\n * Generates text string from node's children textContent.\n * @param node The node whose children to stringify\n * @returns textContent string\n */\nconst textContent = (node: ChildNode): string => {\n  if (!isTag(node)) return node.nodeValue;\n  const { childNodes } = node;\n  if (!childNodes.length) return \"\";\n\n  return childNodes.map((n) =>\n    isTag(n) ? textContent(n as unknown as DOMNode) : n.nodeValue\n  ).join(\"\\n\");\n};\n\n/**\n * Generates HTML string for node's children\n * @param node The node whose children to stringify\n * @param depth Current indentation depth\n * @returns innerHTML string\n */\nconst innerHTML = ({ childNodes }: DOMNode, depth = 0): string => {\n  if (!childNodes.length) return \"\";\n\n  const childIsText = childNodes.length === 1 && !isTag(childNodes[0]);\n  const space = depth && !childIsText ? \"  \".repeat(depth) : \"\";\n\n  return childNodes\n    .filter((n) => n.nodeName !== \"#comment\")\n    .map((n) => isTag(n) ? outerHTML(n, depth) : space + n.nodeValue)\n    .join(\"\\n\");\n};\n\n/**\n * Generates HTML string for a node including its opening/closing tags\n * @param node The node to stringify\n * @param depth Current indentation depth\n * @returns outerHTML string\n */\nconst outerHTML = (node: DOMNode, depth = 0): string => {\n  const space = depth ? \"  \".repeat(depth) : \"\";\n  const { attributes, tagName, childNodes } = node;\n  const hasChildren = childNodes.length > 0;\n  const childIsText = childNodes.length === 1 && !isTag(childNodes[0]);\n  const hasAttributes = attributes.size > 0;\n  const isSelfClosing = selfClosingTags.has(tagName);\n\n  const attrStr = hasAttributes\n    ? \" \" + Array.from(attributes)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .join(\" \")\n    : \"\";\n\n  let output = `${space}<${tagName}${attrStr}${isSelfClosing ? \" /\" : \"\"}>`;\n  output += hasChildren && !childIsText ? \"\\n\" : \"\";\n  output += hasChildren ? innerHTML(node, depth + 1) : \"\";\n  output += !childIsText && hasChildren ? `\\n${space}` : \"\";\n  output += !isSelfClosing ? `</${tagName}>` : \"\";\n\n  return output;\n};\n\n/**\n * Creates a basic text or comment node.\n * @param nodeName The node name (\"#text\" or \"#comment\").\n * @param text The text content of the node.\n * @returns A TextNode or CommentNode object.\n */\nexport function createBasicNode<T extends (\"#text\" | \"#comment\")>(\n  nodeName: T,\n  text: string,\n): TextNode | CommentNode {\n  return {\n    nodeName,\n    nodeValue: nodeName !== \"#text\" ? `<${text}>` : text,\n  } as (TextNode | CommentNode);\n}\n\n/**\n * Creates a DOM-like Node (`DOMNode` or `RootNode`) with DOM API properties and methods.\n * This function extends the basic `NodeLike` from **Parser** by adding DOM-specific\n * properties and methods, as well as applying filters based on the provided configuration.\n *\n * @param this - The `RootNode` when creating a `DOMNode`, or `null` otherwise (in non-strict mode)\n * @param nodeName The tag name of the node to create (or '#document' for the root).\n * @param childNodes Optional child nodes to append to the created node.\n * @returns An extended `DOMNode` or `RootNode` object with DOM API.\n */\nexport function createNode(\n  this: RootNode | null,\n  nodeName: string,\n  ...childNodes: ChildNodeList\n): Omit<DOMNode, \"tagName\" | \"attributes\"> | RootNode {\n  const ALL: ChildElementList = [];\n  const CHILDREN: ChildElementList = [];\n  const CHILDNODES: ChildNodeList = [];\n  const nodeIsRoot = nodeName === \"#document\";\n  const ownerDocument = this ?? undefined;\n\n  const node = {\n    nodeName,\n    append(...nodes: ChildNodeList) {\n      for (const child of nodes) {\n        if (!isNode(child)) {\n          throw new Error(`${DOM_ERROR} Invalid node.`);\n        }\n        CHILDNODES.push(child);\n        if (isTag(child)) {\n          ALL.push(child);\n          CHILDREN.push(child);\n          ownerDocument?.register(child);\n\n          // Add HTML generation methods\n          defineProperties(child, {\n            innerHTML: {\n              enumerable: false,\n              get: () => innerHTML(child),\n            },\n            outerHTML: {\n              enumerable: false,\n              get: () => outerHTML(child),\n            },\n          });\n        }\n\n        defineProperties(child, {\n          // Add text generation methods\n          textContent: {\n            enumerable: false,\n            get: () => textContent(child),\n          },\n          // Add node relationship properties\n          parentNode: {\n            enumerable: false,\n            get: () => node,\n          },\n          parentElement: {\n            enumerable: false,\n            get: () => node,\n          },\n          ownerDocument: {\n            enumerable: false,\n            get: () => ownerDocument,\n          },\n        });\n\n        child.remove = () => {\n          node.removeChild(child);\n        };\n      }\n    },\n    cleanup: () => {\n      ALL.length = 0;\n      CHILDREN.length = 0;\n      CHILDNODES.length = 0;\n    },\n\n    // Root document methods\n    ...(isRoot({ nodeName } as RootNode) && {\n      createElement(\n        tagName:\n          & string\n          & (keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap),\n        first?: NodeLikeAttributes | MaybeChildNode,\n        ...rest: MaybeChildNode[]\n      ) {\n        return createElement.call(\n          node as RootNode,\n          tagName,\n          first,\n          ...rest,\n        );\n      },\n      createElementNS(\n        _ns: string,\n        tagName:\n          & string\n          & (keyof SVGElementTagNameMap & keyof HTMLElementTagNameMap),\n        first?: NodeLikeAttributes | MaybeChildNode,\n        ...rest: MaybeChildNode[]\n      ) {\n        return createElement.call(node as RootNode, tagName, first, ...rest);\n      },\n      createComment(content: string) {\n        return createBasicNode(\"#comment\", content);\n      },\n      createTextNode(content: string) {\n        return createBasicNode(\"#text\", content);\n      },\n      getElementById(id: string) {\n        return ALL.find((node) => node.attributes.get(\"id\") === id) ?? null;\n      },\n    }),\n\n    // Element methods\n    ...((!nodeIsRoot) && {\n      matches(selector: string) {\n        return matchesSelector(node as unknown as DOMNode, selector);\n      },\n    }),\n    // Shared methods\n    contains: (childNode: DOMNode) => {\n      if (!childNode || !isTag(childNode)) {\n        throw new Error(\n          \"DomError: the childNode parameter must be a valid DOMNode\",\n        );\n      }\n      if ((node as DOMNode | RootNode).children.includes(childNode)) {\n        return true;\n      }\n\n      let currentParent = childNode.parentNode;\n      while (currentParent) {\n        if (currentParent === node) {\n          return true;\n        }\n        currentParent = currentParent.parentNode;\n      }\n      return false;\n    },\n    removeChild(childNode: ChildNode) {\n      if (!childNode || !isNode(childNode)) {\n        throw new Error(\n          \"DomError: the childNode parameter must be a valid ChildNode\",\n        );\n      }\n\n      const indexOf = (arr: ChildNode[]) => arr.indexOf(childNode);\n      /* istanbul ignore else @preserve */\n      if (isTag(childNode)) {\n        const idx1 = indexOf(ALL);\n        const idx2 = indexOf(CHILDREN);\n        /* istanbul ignore else @preserve */\n        if (idx1 > -1) ALL.splice(idx1, 1);\n        /* istanbul ignore else @preserve */\n        if (idx2 > -1) CHILDREN.splice(idx2, 1);\n        childNode.cleanup();\n\n        ownerDocument?.deregister(childNode);\n      }\n\n      const idx3 = indexOf(CHILDNODES);\n      /* istanbul ignore else @preserve */\n      if (idx3 > -1) CHILDNODES.splice(idx3, 1);\n    },\n    replaceChildren: (...newChildren: DOMNode[]) => {\n      // clone this array to work\n      CHILDNODES.slice(0).forEach((child) => node.removeChild(child));\n      node.append(...newChildren);\n    },\n    querySelector(selector: string) {\n      return ALL.find((n) => n.matches(selector)) ?? null;\n    },\n    querySelectorAll(selector: string) {\n      return ALL.filter((n) => n.matches(selector));\n    },\n    getElementsByTagName(tagName: string) {\n      return tagName === \"*\"\n        ? ALL\n        : ALL.filter((n) => n.tagName.toLowerCase() === tagName.toLowerCase());\n    },\n    getElementsByClassName(className: string) {\n      return ALL.filter((n) => {\n        const classAttr = n.attributes.get(\"class\");\n        return classAttr?.split(/\\s+/).includes(className) ?? false;\n      });\n    },\n  };\n\n  // Define enumerable getters\n  defineProperties(node, {\n    childNodes: {\n      enumerable: true,\n      get: () => CHILDNODES,\n    },\n    children: {\n      enumerable: true,\n      get: () => CHILDREN,\n    },\n    // Add tag-specific property\n    ...(!nodeIsRoot\n      ? {\n        registerChild: {\n          enumerable: false,\n          value: (child: DOMNode) => {\n            ALL.push(child);\n          },\n        },\n      }\n      : {}),\n  });\n\n  // Add root-specific properties\n  if (nodeIsRoot) {\n    defineProperties(node, {\n      all: {\n        enumerable: true,\n        get: () => ALL,\n      },\n      documentElement: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"HTML\"),\n      },\n      head: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"HEAD\"),\n      },\n      body: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"BODY\"),\n      },\n      register: {\n        enumerable: false,\n        value: (child: DOMNode) => {\n          ALL.push(child);\n        },\n      },\n      deregister: {\n        enumerable: false,\n        value: (child: DOMNode) => {\n          const idx = ALL.indexOf(child);\n          /* istanbul ignore else @preserve */\n          if (idx > -1) ALL.splice(idx, 1);\n        },\n      },\n    });\n  }\n\n  // Add any initial children\n  if (childNodes?.length) {\n    node.append(...childNodes);\n  }\n\n  return node as unknown as RootNode | Omit<DOMNode, \"tagName\" | \"attributes\">;\n}\n\nconst convertToNode = (n: string | number | ChildNode) => {\n  if (isPrimitive(n)) {\n    const { tokenType, value } = tokenize(String(n))[0] as TextToken;\n    return createBasicNode(`#${tokenType}`, value);\n  }\n  return n;\n};\n\n/**\n * Creates a new `Element` like node\n * @param this The RootNode instance\n * @param tagName Tag name for the element\n * @param first Optional attributes or first child\n * @param args Additional child nodes\n * @returns New element node\n */\nexport function createElement(\n  this: RootNode,\n  tagName: string & TagNames,\n  first?: NodeLikeAttributes | MaybeChildNode,\n  ...args: MaybeChildNode[]\n): DOMNode {\n  const childNodes: ChildNodeList = [];\n  let attributes = new Map<string, string>();\n\n  // Handle first argument\n  /* istanbul ignore else @preserve */\n  if (first) {\n    if (isObj(first) && !isNode(first)) {\n      // Convert attributes object to Map\n      attributes = new Map(Object.entries(first));\n    } else {\n      childNodes.push(convertToNode(first as string | number | ChildNode));\n    }\n  }\n\n  // Add remaining children\n  const nodes = args.map(convertToNode).filter(isNode);\n  childNodes.push(...nodes);\n\n  const node = createNode.call(\n    this,\n    toUpperCase(tagName),\n    ...childNodes,\n  ) as DOMNode;\n\n  const charset = attributes.get(\"charset\");\n  if (tagName === \"meta\" && charset) {\n    this.charset = toUpperCase(charset);\n  }\n\n  defineProperties(node, {\n    tagName: {\n      enumerable: true,\n      get: () => tagName,\n    },\n    attributes: {\n      enumerable: true,\n      get: () => attributes,\n    },\n    id: {\n      enumerable: true,\n      get: () => attributes.get(\"id\") ?? \"\",\n    },\n    className: {\n      enumerable: true,\n      get: () => attributes.get(\"class\") ?? \"\",\n    },\n  });\n  // define Element attributes methods\n  node.hasAttribute = (attrName) => attributes.has(attrName);\n  node.getAttribute = (attrName) => attributes.get(attrName) ?? null;\n  node.setAttribute = (attrName, attrValue) => {\n    attributes.set(attrName, attrValue);\n  };\n  node.hasAttributeNS = (_namespace, attrName) => attributes.has(attrName);\n  node.getAttributeNS = (_namespace, attrName) =>\n    attributes.get(attrName) ?? null;\n  node.setAttributeNS = (_namespace, attrName, attrValue) => {\n    attributes.set(attrName, attrValue);\n  };\n  // define Element parent selector\n  node.closest = (selector: string) => {\n    if (!selector) throw new Error(\"DomError: selector must be a string\");\n    if (node.matches(selector)) return node;\n    let currentParent = node.parentNode;\n    while (!isRoot(currentParent)) {\n      if (currentParent.matches(selector)) {\n        return currentParent;\n      }\n      currentParent = currentParent.parentNode;\n    }\n    return null;\n  };\n\n  return node;\n}\n\n/**\n * Creates a new `Document` like root node.\n *\n * @returns a new root node\n */\nexport const createDocument = () =>\n  createNode.call(null, \"#document\") as RootNode;\n","// parser.ts\nimport {\n  getBaseAttributes,\n  selfClosingTags,\n  tokenize,\n  toLowerCase,\n  toUpperCase,\n} from \"./util.ts\";\nimport type {\n  CommentLike,\n  NodeLike,\n  ParseResult,\n  RootLike,\n  TextLike,\n} from \"./types\";\n\n/**\n * **Parser**\n *\n * A tiny yet very fast and powerful parser that takes a string of HTML\n * and returns a DOM tree representation. In benchmarks it shows up to\n * 60x faster performance when compared to jsdom.\n *\n * @example\n * ```ts\n * const { root, components, tags } = Parser().parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a RootLike node,\n * // > \"components\" is an array of component names,\n * // > \"tags\" is an array of tag names.\n * ```\n *\n * @returns The result of the parser.\n */\nexport function Parser() {\n  return {\n    parseFromString(htmlString?: string): ParseResult {\n      const root: RootLike = { nodeName: \"#document\", children: [] };\n      if (!htmlString) return { root, tags: [], components: [] };\n\n      const stack: (RootLike | NodeLike)[] = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      const tokens = tokenize(htmlString);\n      const tLen = tokens.length;\n\n      for (let i = 0; i < tLen; i += 1) {\n        const { tokenType, value, isSC } = tokens[i];\n        const currentParent = stack[stack.length - 1];\n        if (tokenType === \"doctype\") continue;\n\n        if ([\"text\", \"comment\"].includes(tokenType)) {\n          currentParent.children.push(\n            {\n              nodeName: `#${tokenType}`,\n              nodeValue: value,\n            } as CommentLike | TextLike,\n          );\n          continue;\n        }\n\n        const isClosing = value.startsWith(\"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC ||\n          selfClosingTags.has(tagNameLower);\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) ||\n            tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node: NodeLike = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getBaseAttributes(value),\n            children: [],\n          };\n\n          currentParent.children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      };\n    },\n  };\n}\n","// dom-parser.ts\nimport { createBasicNode, createDocument, createElement } from \"./prototype.ts\";\nimport type {\n  ChildNode,\n  DOMNode,\n  DomParserOptions,\n  DomParserResult,\n  GetAttributesOptions,\n  RootNode,\n} from \"./types.ts\";\n\nimport {\n  DOM_ERROR,\n  getAttributes,\n  isObj,\n  selfClosingTags,\n  startsWith,\n  tokenize,\n  toUpperCase,\n} from \"./util.ts\";\n\n/**\n * **DomParser**\n *\n * Unlike the basic **Parser**, **DomParser** creates a new `Document` like instance with DOM-like\n * methods and properties and populates it with `Node` like objects resulted from the parsing\n * of a given HTML markup.\n *\n * @example\n * ```ts\n * const config = {\n *   // On creating new node callback function\n *   onNodeCallback?: myFunction(node: DOMNode) => DOMNode | YOURNode,\n *   // Common dangerous tags that could lead to XSS attacks\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS attacks\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const { root: doc, components, tags } = DomParser.parseFromString(\"<!doctype html><html>This is starting html</html>\", config);\n * console.log(doc.documentElement.outerHTML);\n * // > \"<html>This is starting html</html>\"\n * ```\n *\n * @param startHTML Initial HTML content\n * @param config the `Parser` options to apply to the parsing of the startHTML markup.\n * @returns The `Document` like root node\n */\nexport const DomParser = (\n  config?: Partial<DomParserOptions>,\n) => {\n  if (config && !isObj(config)) {\n    throw new Error(`${DOM_ERROR} 1st parameter is not an object.`);\n  }\n\n  // Common dangerous tags that could lead to XSS\n  let unsafeTags = new Set<string>();\n  let unsafeTagDepth = 0;\n\n  // Unsafe attributes that could lead to XSS\n  let unsafeAttrs = new Set<string>();\n\n  // Apply config\n  const { filterTags, filterAttrs, onNodeCallback } = config || {};\n  if (filterTags?.length) unsafeTags = new Set(filterTags);\n  if (filterAttrs?.length) unsafeAttrs = new Set(filterAttrs);\n  const getAttrOptions = { unsafeAttrs } as GetAttributesOptions;\n  // don't override the default function unless it's actualy set\n\n  return {\n    parseFromString(htmlString?: string) {\n      if (htmlString && typeof htmlString !== \"string\") {\n        throw new Error(`${DOM_ERROR} 1st parameter is not a string.`);\n      }\n      const root = createDocument();\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack: (RootNode | DOMNode)[] = [root];\n      const tagStack: string[] = [];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      const tokens = tokenize(htmlString);\n      const tLen = tokens.length;\n      let newNode: ChildNode;\n\n      for (let i = 0; i < tLen; i += 1) {\n        const { tokenType, value, isSC } = tokens[i];\n\n        // Skip doctype, but store it as a root property\n        if (tokenType === \"doctype\") {\n          root.doctype = `<${value}>`;\n          continue;\n        }\n        const currentParent = stack[stack.length - 1];\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const isSelfClosing = isSC || selfClosingTags.has(tagName);\n\n        // Tag Matching Detection Logic\n        if (tokenType === \"tag\" && !isSelfClosing) {\n          // Start Tag (and not self-closing)\n          if (!isClosing) {\n            // Push tag name onto the tag stack\n            tagStack.push(tagName);\n            // Closing Tag\n          } else {\n            // Pop the last opened tag\n            const expectedTag = tagStack.pop();\n            if (expectedTag !== tagName) {\n              if (expectedTag === undefined) {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. No open tag found.`,\n                );\n              } else {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. Expected closing tag for <${expectedTag}>.`,\n                );\n              }\n            }\n          }\n        }\n\n        // Skip unsafe tags AND their children\n        if (unsafeTags.has(tagName)) {\n          if (!isSelfClosing) {\n            if (!isClosing) {\n              unsafeTagDepth++;\n            } else {\n              unsafeTagDepth--;\n            }\n          }\n          continue;\n        }\n\n        // Don't process anything while inside unsafe tags\n        if (unsafeTagDepth > 0) continue;\n\n        if ([\"text\", \"comment\"].includes(tokenType)) {\n          newNode = createBasicNode(\n            `#${tokenType as \"text\" | \"comment\"}`,\n            value,\n          ) as ChildNode;\n          currentParent.append(newNode);\n          continue;\n        }\n\n        // Register tag/component type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const attributes = getAttributes(value, getAttrOptions);\n          newNode = createElement.call(\n            root,\n            tagName as DOMNode[\"tagName\"],\n            attributes,\n          );\n          currentParent.append(newNode);\n          stack.slice(1, -1).map((parent) =>\n            (parent as DOMNode).registerChild(newNode as DOMNode)\n          );\n\n          if (onNodeCallback) onNodeCallback(newNode, currentParent, root);\n\n          const charset = attributes?.charset;\n          if (tagName === \"meta\" && charset) {\n            root.charset = toUpperCase(charset);\n          }\n\n          !isSelfClosing && stack.push(newNode);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      }\n\n      // Check for unclosed tags at the end\n      // an edge case where end tag is malformed `</incomplete`\n      if (tagStack.length > 0) {\n        const unclosedTag = tagStack.pop();\n        throw new Error(`${DOM_ERROR} Unclosed tag: <${unclosedTag}>.`);\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies DomParserResult;\n    },\n  };\n};\n"],"mappings":"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","names":["node"]}