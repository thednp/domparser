{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["export type ParserOptions = {\n  filterTags?: string[];\n  filterAttrs?: string[];\n};\n\nexport type RootNode = {\n  nodeName: string;\n  children: DOMLike[];\n};\n\nexport type DOMLike = {\n  tagName?: string;\n  nodeName: string;\n  attributes: Record<string, string>;\n  children: DOMLike[];\n  value?: string;\n};\n\nexport type ParseResult = {\n  root: RootNode;\n  components: string[];\n  tags: string[];\n};\n\nexport type HTMLToken = {\n  type: string;\n  value: string;\n  isSC?: boolean;\n};\n\nconst toLowerCase = (str: string): string => str.toLowerCase();\nconst toUpperCase = (str: string): string => str.toUpperCase();\nconst startsWith = (str: string, prefix: string): boolean =>\n  str.startsWith(prefix);\nconst endsWith = (str: string, suffix: string): boolean => str.endsWith(suffix);\n\n/**\n * A basic tool for HTML entities encoding\n * @param str the source string\n * @returns the encoded string\n */\nexport const encodeEntities = (str: string): string =>\n  str.replace(/[&<>\"']/g, (char) => ({\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n  }[char] || /* istanbul ignore next @preserve */ char));\n\n/**\n * Sanitizes URLs in attribute values\n * @param url the URL\n * @returns the sanitized URL\n */\nexport const sanitizeUrl = (url: string): string => {\n  const decoded = decodeURIComponent(url.trim());\n  if (/^(?:javascript|data|vbscript):/i.test(decoded)) return \"\";\n  return encodeEntities(decoded);\n};\n\n/**\n * Sanitizes attribute values\n * @param name the attribute name\n * @param initialValue the attribute value\n * @returns the sanitized value\n */\nexport const sanitizeAttrValue = (\n  name: string,\n  initialValue: string,\n): string => {\n  if (!initialValue) return \"\";\n  const value = initialValue.trim();\n\n  // Special handling for URL attributes\n  if (\n    name === \"src\" || name === \"href\" || name === \"action\" ||\n    name === \"formaction\" || endsWith(name, \"url\")\n  ) {\n    return sanitizeUrl(value);\n  }\n\n  return encodeEntities(value);\n};\n\n/**\n * Get attributes from a string token and return an object\n * where the keys are the names of the attributes and the values\n * are the sanitized values of the attributes.\n *\n * @param tagStr the tring token\n * @param unsafeAttrs an optional set of unsafe attributes\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  unsafeAttrs: Set<string> = new Set(),\n): Record<string, string> => {\n  const attrs: Record<string, string> = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: unknown;\n  const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n  while ((match = attrRegex.exec(attrStr))) {\n    const [, name, d, s, u] = match as RegExpMatchArray;\n    if (name && name !== \"/\" && !unsafeAttrs.has(toLowerCase(name))) {\n      attrs[name] = sanitizeAttrValue(toLowerCase(name), d ?? s ?? u ?? \"\");\n    }\n  }\n\n  return attrs;\n};\n\nconst rootNode: RootNode = {\n  nodeName: \"#document\",\n  children: [],\n};\n\n/**\n * **DOMParser**\n *\n * A tiny yet very fast and powerful HTML parser that\n * takes a string of HTML and returns a simple DOM representation.\n *\n * **Features**\n * * The parser is around 1.2Kb and is optimized for speed and memory efficiency.\n * * The parser handles basic HTML elements, custom elements,\n * UI frameworks components, special attributes, and text nodes.\n * * The parser provides basic sanitization for specific attributes\n * and options to filter tags and attributes; _by default the filters are empty_.\n * * You can also make use of its sanitization tools in your own application.\n * * Fully tested with Vitest.\n *\n * The DOM representation is a plain object with the following structure:\n * ```ts\n *  type DOMLike = {\n *   tagName?: string; // applied only to Element nodes\n *   nodeName: string;\n *   attributes: Record<string, string>;\n *   children: DOMLike[];\n *   value?: string; // applied only to #text nodes\n * };\n * ```\n *\n * @example\n * ```ts\n * const config = {\n *   // Common dangerous tags that could lead to XSS\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const parser = Parser(config);\n * const { root, components, tags } = parser.parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a DOMLike node, \"components\" is an array of component names, \"tags\" is an array of tag names\n * ```\n *\n * @param config an optional configuration object\n * @returns the parsed result\n */\nexport function Parser(config: Partial<ParserOptions> = {}) {\n  const selfClosingTags = new Set([\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n    \"path\",\n    \"circle\",\n    \"ellipse\",\n    \"line\",\n    \"rect\",\n    \"use\",\n    \"stop\",\n    \"polygon\",\n    \"polyline\",\n  ]);\n\n  // Common dangerous tags that could lead to XSS\n  const unsafeTags = new Set<string>();\n\n  // Unsafe attributes that could lead to XSS\n  const unsafeAttrs = new Set<string>();\n\n  // Apply config\n  /* istanbul ignore else @preserve */\n  if (config) {\n    const { filterTags, filterAttrs } = config;\n    if (filterTags) filterTags.forEach((tag) => unsafeTags.add(tag));\n    if (filterAttrs) filterAttrs.forEach((attr) => unsafeAttrs.add(attr));\n  }\n\n  const tokenize = (html: string): HTMLToken[] => {\n    const tokens: HTMLToken[] = [];\n    let token = \"\", inTag = false, inQuote = false, quote = 0;\n\n    for (let i = 0; i < html.length; i++) {\n      const char = html.charCodeAt(i);\n\n      if (inTag && (char === 34 || char === 39)) { // \" or ' | 0x22 or 0x27\n        if (!inQuote) {\n          quote = char;\n          inQuote = true;\n        } else if (char === quote) inQuote = false;\n        token += String.fromCharCode(char);\n        continue;\n      }\n\n      if (char === 60 /* 0x3c */ && !inQuote) { // <\n        token.trim() && tokens.push({\n          type: \"text\",\n          value: encodeEntities(token.trim()),\n          isSC: false,\n        });\n        token = \"\";\n        inTag = true;\n      } else if (char === 62 /* 0x3e */ && !inQuote) { // > | 0x3e\n        /* istanbul ignore else @preserve */\n        if (token) {\n          const isSC = endsWith(token, \"/\");\n          tokens.push({\n            type: \"tag\",\n            value: isSC ? token.slice(0, -1).trim() : token.trim(),\n            isSC,\n          });\n        }\n        token = \"\";\n        inTag = false;\n      } else {\n        token += String.fromCharCode(char);\n      }\n    }\n\n    token.trim() && tokens.push({\n      type: \"text\",\n      value: encodeEntities(token.trim()),\n      isSC: false,\n    });\n    return tokens;\n  };\n\n  return {\n    parseFromString(htmlString?: string) {\n      const root: RootNode = { ...rootNode, children: [] };\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      let parentIsSafe = true;\n\n      tokenize(htmlString).forEach((token) => {\n        const { value, isSC } = token;\n\n        if (token.type === \"text\") {\n          stack[stack.length - 1].children.push({\n            // attributes: {},\n            // children: [],\n            nodeName: \"#text\",\n            value,\n          } as DOMLike);\n          return;\n        }\n\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC || selfClosingTags.has(tagNameLower);\n\n        // Skip unsafe tags\n        if (unsafeTags.has(tagNameLower)) {\n          if (isClosing) {\n            parentIsSafe = true;\n          } else {\n            parentIsSafe = false;\n          }\n          return;\n        }\n\n        if (!parentIsSafe) return;\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getAttributes(value, unsafeAttrs),\n            children: [],\n          };\n\n          stack[stack.length - 1].children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      });\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies ParseResult;\n    },\n  };\n}\n"],"names":["toLowerCase","str","toUpperCase","startsWith","prefix","endsWith","suffix","encodeEntities","char","sanitizeUrl","url","decoded","sanitizeAttrValue","name","initialValue","value","getAttributes","tagStr","unsafeAttrs","attrs","parts","attrStr","match","attrRegex","d","s","u","rootNode","Parser","config","selfClosingTags","unsafeTags","filterTags","filterAttrs","tag","attr","tokenize","html","tokens","token","inTag","inQuote","quote","i","isSC","htmlString","root","stack","components","tags","parentIsSafe","isClosing","tagName","tagNameLower","isSelfClosing","node"],"mappings":"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"}