{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["export type ParserOptions = {\n  filterTags?: string[];\n  filterAttrs?: string[];\n};\n\nexport type RootNode = {\n  nodeName: string;\n  children: DOMLike[];\n};\n\nexport type DOMLike = {\n  tagName?: string;\n  nodeName: string;\n  attributes: Record<string, string>;\n  children: DOMLike[];\n  nodeValue?: string;\n};\n\nexport type ParseResult = {\n  root: RootNode;\n  components: string[];\n  tags: string[];\n};\n\nexport type HTMLToken = {\n  nodeType: string;\n  value: string;\n  isSC?: boolean;\n};\n\nconst toLowerCase = (str: string): string => str.toLowerCase();\nconst toUpperCase = (str: string): string => str.toUpperCase();\nconst startsWith = (str: string, prefix: string): boolean =>\n  str.startsWith(prefix);\nconst endsWith = (str: string, suffix: string): boolean => str.endsWith(suffix);\nconst charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * A basic tool for HTML entities encoding\n * @param str the source string\n * @returns the encoded string\n */\nexport const encodeEntities = (str: string): string =>\n  str.replace(/[&<>\"']/g, (char) => ({\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n  }[char] || /* istanbul ignore next @preserve */ char));\n\n/**\n * Sanitizes URLs in attribute values\n * @param url the URL\n * @returns the sanitized URL\n */\nexport const sanitizeUrl = (url: string): string => {\n  const decoded = decodeURIComponent(url.trim());\n  if (/^(?:javascript|data|vbscript):/i.test(decoded)) return \"\";\n  return encodeEntities(decoded);\n};\n\n/**\n * Sanitizes attribute values\n * @param name the attribute name\n * @param initialValue the attribute value\n * @returns the sanitized value\n */\nexport const sanitizeAttrValue = (\n  name: string,\n  initialValue: string,\n): string => {\n  if (!initialValue) return \"\";\n  const value = initialValue.trim();\n\n  // Special handling for URL attributes\n  if (\n    name === \"src\" || name === \"href\" || name === \"action\" ||\n    name === \"formaction\" || endsWith(name, \"url\")\n  ) {\n    return sanitizeUrl(value);\n  }\n\n  return encodeEntities(value);\n};\n\n/**\n * Get attributes from a string token and return an object\n * where the keys are the names of the attributes and the values\n * are the sanitized values of the attributes.\n *\n * @param tagStr the tring token\n * @param unsafeAttrs an optional set of unsafe attributes\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  unsafeAttrs: Set<string> = new Set(),\n): Record<string, string> => {\n  const attrs: Record<string, string> = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: unknown;\n  const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n  while ((match = attrRegex.exec(attrStr))) {\n    const [, name, d, s, u] = match as RegExpMatchArray;\n    if (name && name !== \"/\" && !unsafeAttrs.has(toLowerCase(name))) {\n      attrs[name] = sanitizeAttrValue(toLowerCase(name), d ?? s ?? u ?? \"\");\n    }\n  }\n\n  return attrs;\n};\n\nconst rootNode: RootNode = {\n  nodeName: \"#document\",\n  children: [],\n};\n\n/**\n * **DOMParser**\n *\n * A tiny yet very fast and powerful HTML parser that\n * takes a string of HTML and returns a simple DOM representation.\n *\n * **Features**\n * * The parser is around 1.2Kb and is optimized for speed and memory efficiency.\n * * The parser handles basic HTML elements, custom elements,\n * UI frameworks components, special attributes, and text nodes.\n * * The parser provides basic sanitization for specific attributes\n * and options to filter tags and attributes; _by default the filters are empty_.\n * * You can also make use of its sanitization tools in your own application.\n * * Fully tested with Vitest.\n *\n * The DOM representation is a plain object with the following structure:\n * ```ts\n *  type DOMLike = {\n *   tagName?: string; // applied only to Element nodes\n *   nodeName: string;\n *   attributes: Record<string, string>;\n *   children: DOMLike[];\n *   value?: string; // applied only to #text nodes\n * };\n * ```\n *\n * @example\n * ```ts\n * const config = {\n *   // Common dangerous tags that could lead to XSS\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const parser = Parser(config);\n * const { root, components, tags } = parser.parseFromString(\"<h1>Title</h1>\");\n * // > \"root\" is a DOMLike node, \"components\" is an array of component names, \"tags\" is an array of tag names\n * ```\n *\n * @param config an optional configuration object\n * @returns the parsed result\n */\nexport function Parser(config: Partial<ParserOptions> = {}) {\n  const selfClosingTags = new Set([\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n    \"path\",\n    \"circle\",\n    \"ellipse\",\n    \"line\",\n    \"rect\",\n    \"use\",\n    \"stop\",\n    \"polygon\",\n    \"polyline\",\n  ]);\n\n  // Common dangerous tags that could lead to XSS\n  const unsafeTags = new Set<string>();\n\n  // Unsafe attributes that could lead to XSS\n  const unsafeAttrs = new Set<string>();\n\n  // Apply config\n  /* istanbul ignore else @preserve */\n  if (config) {\n    const { filterTags, filterAttrs } = config;\n    if (filterTags) filterTags.forEach((tag) => unsafeTags.add(tag));\n    if (filterAttrs) filterAttrs.forEach((attr) => unsafeAttrs.add(attr));\n  }\n\n  const tokenize = (html: string): HTMLToken[] => {\n    const tokens: HTMLToken[] = [];\n    let token = \"\",\n      inTag = false,\n      inQuote = false,\n      quote = 0,\n      isComment = false;\n\n    for (let i = 0; i < html.length; i++) {\n      const char = charCodeAt(html, i);\n\n      if (isComment) {\n        token += String.fromCharCode(char);\n        if (endsWith(token, \"--\")) {\n          /* istanbul ignore else @preserve */\n          if (charCodeAt(html, i + 1) === 62 /* > */) {\n            tokens.push({\n              nodeType: \"comment\",\n              value: token.trim(),\n              isSC: false,\n            });\n            token = \"\";\n            isComment = false;\n            i++;\n          }\n        }\n        continue;\n      }\n\n      if (inTag && (char === 34 || char === 39)) { // \" or ' | 0x22 or 0x27\n        if (!inQuote) {\n          quote = char;\n          inQuote = true;\n        } else if (char === quote) inQuote = false;\n        token += String.fromCharCode(char);\n        continue;\n      }\n\n      if (char === 60 /* 0x3c */ && !inQuote) { // <\n        token.trim() && tokens.push({\n          nodeType: \"text\",\n          value: encodeEntities(token.trim()),\n          isSC: false,\n        });\n        token = \"\";\n        inTag = true;\n        if (\n          charCodeAt(html, i + 1) === 33 /* ! | 0x21 */ &&\n          charCodeAt(html, i + 2) === 45 /* - | 0x2d */ &&\n          charCodeAt(html, i + 3) === 45 /* - | 0x2d */\n        ) {\n          isComment = true;\n          token += \"!--\";\n          i += 3;\n          continue;\n        }\n      } else if (char === 62 /* 0x3e */ && !inQuote && inTag && !isComment) { // > | 0x3e\n        /* istanbul ignore else @preserve */\n        if (token) {\n          const isSC = endsWith(token, \"/\");\n          const isDocType = startsWith(token, \"!doctype\");\n          // console.log({ token, isDocType });\n          tokens.push({\n            nodeType: isDocType ? \"doctype\" : \"tag\",\n            value: isSC ? token.slice(0, -1).trim() : token.trim(),\n            isSC,\n          });\n        }\n        token = \"\";\n        inTag = false;\n      } else {\n        token += String.fromCharCode(char);\n      }\n    }\n\n    token.trim() && tokens.push({\n      nodeType: \"text\",\n      value: encodeEntities(token.trim()),\n      isSC: false,\n    });\n    return tokens;\n  };\n\n  return {\n    parseFromString(htmlString?: string) {\n      const root: RootNode = { ...rootNode, children: [] };\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack = [root];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      let parentIsSafe = true;\n\n      tokenize(htmlString).forEach((token) => {\n        const { nodeType, value, isSC } = token;\n        // Skip doctype, we already have a root\n        if (nodeType === \"doctype\") return;\n\n        if ([\"text\", \"comment\"].includes(nodeType)) {\n          stack[stack.length - 1].children.push({\n            nodeName: `#${nodeType}`,\n            nodeValue: nodeType === \"text\" ? value : `<${value}>`,\n          } as DOMLike);\n          return;\n        }\n\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC || selfClosingTags.has(tagNameLower);\n\n        // Skip unsafe tags\n        if (unsafeTags.has(tagNameLower)) {\n          if (isClosing) {\n            parentIsSafe = true;\n          } else {\n            parentIsSafe = false;\n          }\n          return;\n        }\n\n        if (!parentIsSafe) return;\n\n        // Register tag type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const node = {\n            tagName,\n            nodeName: toUpperCase(tagName),\n            attributes: getAttributes(value, unsafeAttrs),\n            children: [],\n          };\n\n          stack[stack.length - 1].children.push(node);\n          !isSelfClosing && stack.push(node);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      });\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies ParseResult;\n    },\n  };\n}\n"],"names":["toLowerCase","str","toUpperCase","startsWith","prefix","endsWith","suffix","charCodeAt","index","encodeEntities","char","sanitizeUrl","url","decoded","sanitizeAttrValue","name","initialValue","value","getAttributes","tagStr","unsafeAttrs","attrs","parts","attrStr","match","attrRegex","d","s","u","rootNode","Parser","config","selfClosingTags","unsafeTags","filterTags","filterAttrs","tag","attr","tokenize","html","tokens","token","inTag","inQuote","quote","isComment","isSC","isDocType","htmlString","root","stack","components","tags","parentIsSafe","nodeType","isClosing","tagName","tagNameLower","isSelfClosing","node"],"mappings":"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"}