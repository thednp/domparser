{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import type { DOMNode, HTMLToken, ParseResult } from \"./types\";\nexport { DOMNode, HTMLToken, ParseResult };\n\n/** A full list of self-closing tags */\nconst selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\n/**\n * Returns a quoted string if the key is a valid identifier,\n * otherwise returns the original key.\n * @param key\n * @returns\n */\nconst quoteText = (key: string) =>\n  /^[a-zA-Z_][a-zA-Z_0-9]+$/.test(key) ? key : `\"${key}\"`;\n\n/**\n * A basic HTML parser that takes a string of HTML and returns a simple DOM representation.\n * The parser handles basic HTML elements, attributes, and text content.\n * The DOM representation is a plain object with the following structure:\n * ```\n * {\n *     tagName?: string,\n *     nodeName: string,\n *     attributes: {\n *         [key: string]: string\n *     },\n *     children: [\n *         {\n *             tagName?: string,\n *             attributes: {\n *                 [key: string]: string\n *             },\n *             children: [...],\n *             value: string\n *         }\n *     ]\n * }\n * ```\n */\nexport default class DOMParser {\n  static selfClosingTags = selfClosingTags;\n  static quoteText = quoteText;\n  tags = new Set<string>();\n  components = new Set<string>();\n  root: DOMNode = { nodeName: \"#document\", attributes: {}, children: [] };\n  stack: Array<DOMNode> = [this.root];\n  currentNode: DOMNode = this.root;\n\n  /**\n   * Returns a simple DOM representation of the parsed HTML.\n   * @param htmlString The string of HTML to be parsed.\n   * @return the parsed result.\n   */\n  parseFromString(htmlString: string): ParseResult {\n    const tokens = this.tokenize(htmlString);\n    this.parseTokens(tokens);\n    const root = this.root;\n    return {\n      root,\n      components: Array.from(this.components),\n      tags: Array.from(this.tags),\n    };\n  }\n\n  /**\n   * Parse a string of HTML and return an array of tokens\n   * where each token is an object with a type property and a value property.\n   *\n   * @param htmlString The string of HTML to be tokenized.\n   * @return The array of tokens.\n   */\n  tokenize(htmlString: string): Array<HTMLToken> {\n    const tokens = [];\n    let currentToken = \"\";\n    let inTag = false;\n    let inQuote = false;\n    let quoteChar = 0x22;\n\n    for (let i = 0; i < htmlString.length; i++) {\n      const charCode = htmlString.charCodeAt(i);\n\n      // Handle quotes inside tags\n      if (inTag && (charCode === 0x22 /* \" */ || charCode === 0x27 /* ' */)) {\n        /* istanbul ignore else @preserve */\n        if (!inQuote) {\n          inQuote = true;\n          quoteChar = charCode;\n        } else if (charCode === quoteChar) {\n          inQuote = false;\n        }\n        currentToken += String.fromCharCode(charCode);\n        continue;\n      }\n\n      if (charCode === 0x3c /* < */ && !inQuote) {\n        if (currentToken.trim()) {\n          tokens.push({ type: \"text\", value: currentToken.trim() });\n        }\n        currentToken = \"\";\n        inTag = true;\n      } else if (charCode === 0x3e /* > */ && !inQuote) {\n        /* istanbul ignore else @preserve */\n        if (currentToken) {\n          // Check if it's a self-closing tag\n          const isSelfClosing = currentToken.endsWith(\"/\");\n          if (isSelfClosing) {\n            currentToken = currentToken.slice(0, -1);\n          }\n          tokens.push({\n            type: \"tag\",\n            value: currentToken.trim(),\n            isSelfClosing,\n          });\n        }\n        currentToken = \"\";\n        inTag = false;\n      } else {\n        currentToken += String.fromCharCode(charCode);\n      }\n    }\n\n    /* istanbul ignore if @preserve */\n    if (currentToken.trim()) {\n      tokens.push({\n        type: \"text\",\n        value: currentToken.trim(),\n        isSelfClosing: false,\n      });\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Parse an array of tokens into a DOM representation.\n   * @param tokens An array of tokens to be parsed.\n   */\n  parseTokens(tokens: Array<HTMLToken>) {\n    // reset parser state\n    this.root = { nodeName: \"#document\", attributes: {}, children: [] };\n    this.stack = [this.root];\n    this.currentNode = this.root;\n\n    // iterate over tokens\n    for (const token of tokens) {\n      let tagName = this.getTagName(token.value);\n      const isClosingTag = token.value.startsWith(\"/\");\n      const isSelfClosing = token.isSelfClosing;\n\n      tagName = isClosingTag\n        ? token.value.slice(1)\n        : this.getTagName(token.value);\n\n      /* istanbul ignore else @preserve */\n      if (token.type === \"tag\") {\n        tagName = tagName.replace(/\\/$/, \"\"); // Remove trailing slash for self-closing tags\n        const isComponent = tagName[0].toUpperCase() === tagName[0] ||\n          tagName.includes(\"-\");\n\n        if (isComponent) {\n          this.components.add(tagName);\n        } else {\n          this.tags.add(tagName);\n        }\n\n        if (!isClosingTag) {\n          const newNode = {\n            tagName,\n            nodeName: tagName.toUpperCase(),\n            attributes: isSelfClosing ? {} : this.getAttributes(token.value),\n            isSelfClosing,\n            children: [],\n          };\n\n          if (isSelfClosing) {\n            // Handle self-closing tag\n            this.currentNode.children.push(newNode);\n            // Don't push to stack since self-closing tags don't wrap content\n          } else {\n            this.currentNode.children.push(newNode);\n            this.stack.push(newNode);\n            this.currentNode = newNode;\n          }\n        } else {\n          this.stack.pop();\n          /* istanbul ignore else @preserve */\n          if (this.stack.length > 0) {\n            this.currentNode = this.stack[this.stack.length - 1];\n          }\n        }\n      } else if (token.type === \"text\") {\n        const textNode = {\n          nodeName: \"#text\",\n          attributes: {},\n          children: [],\n          value: token.value,\n        };\n        this.currentNode.children.push(textNode);\n      }\n    }\n  }\n\n  /**\n   * Returns the name of the tag.\n   * @param tagString A string of HTML that represents a tag.\n   * @return The name of the tag.\n   */\n  getTagName(tagString: string): string {\n    return tagString.split(/[\\s/>]/)[0];\n  }\n\n  /**\n   * Returns an object where the keys are the names of the attributes\n   * and the values are the values of the attributes.\n   *\n   * @param tagString A string of HTML that represents a tag.\n   * @return an object where the keys are the names of the attributes and the values are the values of the attributes.\n   */\n  getAttributes(tagString: string): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n    const tagParts = tagString.split(/\\s+/);\n\n    if (tagParts.length < 2) return attributes;\n\n    const attrString = tagString.slice(tagParts[0].length);\n    let match;\n\n    while ((match = attrRegex.exec(attrString)) !== null) {\n      const [, name, doubleQuoted, singleQuoted, unquoted] = match;\n      /* istanbul ignore else @preserve */\n      if (name && name !== \"/\") {\n        attributes[name] = doubleQuoted ||\n          /* istanbul ignore next @preserve */ singleQuoted ||\n          /* istanbul ignore next @preserve */ unquoted ||\n          /* istanbul ignore next @preserve */ \"\";\n      }\n    }\n\n    return attributes;\n  }\n}\n"],"names":["selfClosingTags","quoteText","key","DOMParser","__publicField","htmlString","tokens","currentToken","inTag","inQuote","quoteChar","i","charCode","isSelfClosing","token","tagName","isClosingTag","newNode","textNode","tagString","attributes","attrRegex","tagParts","attrString","match","name","doubleQuoted","singleQuoted","unquoted"],"mappings":"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"}