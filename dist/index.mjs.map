{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import type { DOMNode, HTMLToken, ParseResult } from \"./types\";\nexport { DOMNode, HTMLToken, ParseResult };\n\n/** A full list of self-closing tags */\nconst selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\n/**\n * Returns a quoted string if the key is a valid identifier,\n * otherwise returns the original key.\n * @param key\n * @returns\n */\nconst quoteText = (key: string) =>\n  /^[a-zA-Z_][a-zA-Z_0-9]+$/.test(key) ? key : `\"${key}\"`;\n\n/**\n * A basic HTML parser that takes a string of HTML and returns a simple DOM representation.\n * The parser handles basic HTML elements, attributes, and text content.\n * The DOM representation is a plain object with the following structure:\n * ```\n * {\n *     tagName?: string,\n *     nodeName: string,\n *     attributes: {\n *         [key: string]: string\n *     },\n *     children: [\n *         {\n *             tagName?: string,\n *             attributes: {\n *                 [key: string]: string\n *             },\n *             children: [...],\n *             value: string\n *         }\n *     ]\n * }\n * ```\n */\nexport default class DOMParser {\n  static selfClosingTags = selfClosingTags;\n  static quoteText = quoteText;\n  tags = new Set<string>();\n  components = new Set<string>();\n  root: DOMNode = { nodeName: \"#document\", attributes: {}, children: [] };\n  stack: Array<DOMNode> = [this.root];\n  currentNode: DOMNode = this.root;\n\n  /**\n   * Returns a simple DOM representation of the parsed HTML.\n   * @param htmlString The string of HTML to be parsed.\n   * @return the parsed result.\n   */\n  parseFromString(htmlString: string): ParseResult {\n    const tokens = this.tokenize(htmlString);\n    this.parseTokens(tokens);\n    const root = this.root;\n    return {\n      root,\n      components: Array.from(this.components),\n      tags: Array.from(this.tags),\n    };\n  }\n\n  /**\n   * Parse a string of HTML and return an array of tokens\n   * where each token is an object with a type property and a value property.\n   *\n   * @param htmlString The string of HTML to be tokenized.\n   * @return The array of tokens.\n   */\n  tokenize(htmlString: string): Array<HTMLToken> {\n    const tokens = [];\n    let currentToken = \"\";\n    let inTag = false;\n    let inQuote = false;\n    let quoteChar = 0x22;\n\n    for (let i = 0; i < htmlString.length; i++) {\n      const charCode = htmlString.charCodeAt(i);\n\n      if (inTag && (charCode === 0x22 /* \" */ || charCode === 0x27 /* ' */)) {\n        /* istanbul ignore else @preserve */\n        if (!inQuote) {\n          inQuote = true;\n          quoteChar = charCode;\n        } else if (charCode === quoteChar) {\n          inQuote = false;\n        }\n        currentToken += String.fromCharCode(charCode);\n        continue;\n      }\n\n      if (charCode === 0x3c /* < */ && !inQuote) {\n        const value = currentToken.trim();\n        if (value) {\n          tokens.push({ type: \"text\", value, isSelfClosing: false });\n        }\n        currentToken = \"\";\n        inTag = true;\n      } else if (charCode === 0x3e /* > */ && !inQuote) {\n        /* istanbul ignore else @preserve */\n        if (currentToken) {\n          const isSelfClosing = currentToken.endsWith(\"/\");\n          if (isSelfClosing) {\n            currentToken = currentToken.slice(0, -1);\n          }\n          tokens.push({\n            type: \"tag\",\n            value: currentToken.trim(),\n            isSelfClosing,\n          });\n        }\n        currentToken = \"\";\n        inTag = false;\n      } else {\n        currentToken += String.fromCharCode(charCode);\n      }\n    }\n\n    /* istanbul ignore if @preserve */\n    if (currentToken.trim()) {\n      tokens.push({\n        type: \"text\",\n        value: currentToken.trim(),\n        isSelfClosing: false,\n      });\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Parse an array of tokens into a DOM representation.\n   * @param tokens An array of tokens to be parsed.\n   */\n  parseTokens(tokens: Array<HTMLToken>) {\n    // reset parser state\n    this.root = { nodeName: \"#document\", attributes: {}, children: [] };\n    this.stack = [this.root];\n    this.currentNode = this.root;\n\n    for (const token of tokens) {\n      if (token.type === \"text\") {\n        const textNode = {\n          nodeName: \"#text\",\n          attributes: {},\n          children: [],\n          value: token.value,\n        };\n        this.currentNode.children.push(textNode);\n        continue;\n      }\n\n      // Handle tags\n      const isClosingTag = token.value.startsWith(\"/\");\n      const tagName = isClosingTag\n        ? token.value.slice(1)\n        : this.getTagName(token.value);\n\n      const isSelfClosing = token.isSelfClosing || selfClosingTags.has(tagName);\n\n      // Register tag type\n      const isComponent = tagName[0].toUpperCase() === tagName[0] ||\n        tagName.includes(\"-\");\n      if (isComponent) {\n        this.components.add(tagName);\n      } else {\n        this.tags.add(tagName);\n      }\n\n      if (!isClosingTag) {\n        const newNode = {\n          tagName,\n          nodeName: tagName.toUpperCase(),\n          attributes: this.getAttributes(token.value),\n          children: [],\n        };\n\n        this.currentNode.children.push(newNode);\n\n        // Only push to stack if it's not a self-closing tag\n        if (!isSelfClosing) {\n          this.stack.push(newNode);\n          this.currentNode = newNode;\n        }\n      } else {\n        // Only pop the stack if we're closing a non-self-closing tag\n        if (!isSelfClosing && this.stack.length > 1) {\n          this.stack.pop();\n          this.currentNode = this.stack[this.stack.length - 1];\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the name of the tag.\n   * @param tagString A string of HTML that represents a tag.\n   * @return The name of the tag.\n   */\n  getTagName(tagString: string): string {\n    return tagString.split(/[\\s/>]/)[0];\n  }\n\n  /**\n   * Returns an object where the keys are the names of the attributes\n   * and the values are the values of the attributes.\n   *\n   * @param tagString A string of HTML that represents a tag.\n   * @return an object where the keys are the names of the attributes and the values are the values of the attributes.\n   */\n  getAttributes(tagString: string): Record<string, string> {\n    const attributes: Record<string, string> = {};\n    const attrRegex = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n    const tagParts = tagString.split(/\\s+/);\n\n    if (tagParts.length < 2) return attributes;\n\n    const attrString = tagString.slice(tagParts[0].length);\n    let match;\n\n    while ((match = attrRegex.exec(attrString)) !== null) {\n      const [, name, doubleQuoted, singleQuoted, unquoted] = match;\n      /* istanbul ignore else @preserve */\n      if (name && name !== \"/\") {\n        attributes[name] = doubleQuoted ||\n          /* istanbul ignore next @preserve */ singleQuoted ||\n          /* istanbul ignore next @preserve */ unquoted ||\n          /* istanbul ignore next @preserve */ \"\";\n      }\n    }\n\n    return attributes;\n  }\n}\n"],"names":["selfClosingTags","quoteText","key","DOMParser","__publicField","htmlString","tokens","currentToken","inTag","inQuote","quoteChar","charCode","value","isSelfClosing","token","textNode","isClosingTag","tagName","newNode","tagString","attributes","attrRegex","tagParts","attrString","match","name","doubleQuoted","singleQuoted","unquoted"],"mappings":"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"}