{"version":3,"sources":["../src/parts/dom-parser.ts"],"sourcesContent":["// dom-parser.ts\nimport { createBasicNode, createDocument, createElement } from \"./prototype.ts\";\nimport type {\n  ChildNode,\n  DOMNode,\n  DomParserOptions,\n  DomParserResult,\n  GetAttributesOptions,\n  RootNode,\n} from \"./types.ts\";\n\nimport {\n  DOM_ERROR,\n  getAttributes,\n  isObj,\n  selfClosingTags,\n  startsWith,\n  tokenize,\n  toUpperCase,\n} from \"./util.ts\";\n\n/**\n * **DomParser**\n *\n * Unlike the basic **Parser**, **DomParser** creates a new `Document` like instance with DOM-like\n * methods and properties and populates it with `Node` like objects resulted from the parsing\n * of a given HTML markup.\n *\n * @example\n * ```ts\n * const config = {\n *   // On creating new node callback function\n *   onNodeCallback?: myFunction(node: DOMNode) => DOMNode | YOURNode,\n *   // Common dangerous tags that could lead to XSS attacks\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS attacks\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const { root: doc, components, tags } = DomParser.parseFromString(\"<!doctype html><html>This is starting html</html>\", config);\n * console.log(doc.documentElement.outerHTML);\n * // > \"<html>This is starting html</html>\"\n * ```\n *\n * @param startHTML Initial HTML content\n * @param config the `Parser` options to apply to the parsing of the startHTML markup.\n * @returns The `Document` like root node\n */\nexport const DomParser = (\n  config?: Partial<DomParserOptions>,\n) => {\n  if (config && !isObj(config)) {\n    throw new Error(`${DOM_ERROR} 1st parameter is not an object.`);\n  }\n\n  // Common dangerous tags that could lead to XSS\n  let unsafeTags = new Set<string>();\n  let unsafeTagDepth = 0;\n\n  // Unsafe attributes that could lead to XSS\n  let unsafeAttrs = new Set<string>();\n\n  // Apply config\n  const { filterTags, filterAttrs, onNodeCallback } = config || {};\n  if (filterTags?.length) unsafeTags = new Set(filterTags);\n  if (filterAttrs?.length) unsafeAttrs = new Set(filterAttrs);\n  const getAttrOptions = { unsafeAttrs } as GetAttributesOptions;\n  // don't override the default function unless it's actualy set\n\n  return {\n    parseFromString(htmlString?: string) {\n      if (htmlString && typeof htmlString !== \"string\") {\n        throw new Error(`${DOM_ERROR} 1st parameter is not a string.`);\n      }\n      const root = createDocument();\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack: (RootNode | DOMNode)[] = [root];\n      const tagStack: string[] = [];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      const tokens = tokenize(htmlString);\n      const tLen = tokens.length;\n      let newNode: ChildNode;\n\n      for (let i = 0; i < tLen; i += 1) {\n        const { tokenType, value, isSC } = tokens[i];\n\n        // Skip doctype, but store it as a root property\n        if (tokenType === \"doctype\") {\n          root.doctype = `<${value}>`;\n          continue;\n        }\n        const currentParent = stack[stack.length - 1];\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const isSelfClosing = isSC || selfClosingTags.has(tagName);\n\n        // Tag Matching Detection Logic\n        if (tokenType === \"tag\" && !isSelfClosing) {\n          // Start Tag (and not self-closing)\n          if (!isClosing) {\n            // Push tag name onto the tag stack\n            tagStack.push(tagName);\n            // Closing Tag\n          } else {\n            // Pop the last opened tag\n            const expectedTag = tagStack.pop();\n            if (expectedTag !== tagName) {\n              if (expectedTag === undefined) {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. No open tag found.`,\n                );\n              } else {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. Expected closing tag for <${expectedTag}>.`,\n                );\n              }\n            }\n          }\n        }\n\n        // Skip unsafe tags AND their children\n        if (unsafeTags.has(tagName)) {\n          if (!isSelfClosing) {\n            if (!isClosing) {\n              unsafeTagDepth++;\n            } else {\n              unsafeTagDepth--;\n            }\n          }\n          continue;\n        }\n\n        // Don't process anything while inside unsafe tags\n        if (unsafeTagDepth > 0) continue;\n\n        if ([\"text\", \"comment\"].includes(tokenType)) {\n          newNode = createBasicNode(\n            `#${tokenType as \"text\" | \"comment\"}`,\n            value,\n          ) as ChildNode;\n          currentParent.append(newNode);\n          continue;\n        }\n\n        // Register tag/component type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const attributes = getAttributes(value, getAttrOptions);\n          newNode = createElement.call(\n            root,\n            tagName as DOMNode[\"tagName\"],\n            attributes,\n          );\n          currentParent.append(newNode);\n          stack.slice(1, -1).map((parent) =>\n            (parent as DOMNode).registerChild(newNode as DOMNode)\n          );\n\n          if (onNodeCallback) onNodeCallback(newNode, currentParent, root);\n\n          const charset = attributes?.charset;\n          if (tagName === \"meta\" && charset) {\n            root.charset = toUpperCase(charset);\n          }\n\n          !isSelfClosing && stack.push(newNode);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      }\n\n      // Check for unclosed tags at the end\n      // an edge case where end tag is malformed `</incomplete`\n      if (tagStack.length > 0) {\n        const unclosedTag = tagStack.pop();\n        throw new Error(`${DOM_ERROR} Unclosed tag: <${unclosedTag}>.`);\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies DomParserResult;\n    },\n  };\n};\n"],"mappings":"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","names":[]}