{"version":3,"sources":["/home/artae/Work/Github/domparser/dist/dom-parser.cjs","../src/parts/util.ts","../src/parts/selectors.ts","../src/parts/prototype.ts","../src/parts/dom-parser.ts"],"names":["node"],"mappings":"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","file":"/home/artae/Work/Github/domparser/dist/dom-parser.cjs","sourcesContent":[null,"// util.ts\nimport type {\n  ChildLike,\n  ChildNode,\n  DOMNode,\n  GetAttributesOptions,\n  HTMLToken,\n  NodeLike,\n  NodeLikeAttributes,\n  RootLike,\n  RootNode,\n} from \"./types.ts\";\n\n// general utils\n\nexport const ATTR_REGEX = /([^\\s=]+)(?:=(?:\"([^\"]*)\"|'([^']*)'|([^\\s\"']+)))?/g;\n\n/**\n * Get attributes from a string token and return an object\n * @param tagStr the string token\n * @returns the attributes object\n */\nexport const getBaseAttributes = (tagStr: string) => {\n  const attrs: NodeLikeAttributes = {};\n  const parts = tagStr.split(/\\s+/);\n  if (parts.length < 2) return attrs;\n\n  const attrStr = tagStr.slice(parts[0].length);\n  let match: RegExpExecArray | null;\n\n  while ((match = ATTR_REGEX.exec(attrStr))) {\n    const [, name, d, s, u] = match;\n    name !== \"/\" && (attrs[name] = d ?? s ?? u ?? \"\");\n  }\n\n  return attrs;\n};\n\n/**\n * Get attributes from a string token and return an object.\n * In addition to the base tool, this also filters configured\n * unsafe attributes and sanitization.\n * @param tagStr the string token\n * @param config an optional set of options\n * @returns the attributes object\n */\nexport const getAttributes = (\n  tagStr: string,\n  config?: Partial<GetAttributesOptions>,\n): NodeLikeAttributes => {\n  const { unsafeAttrs } = config || {};\n  const baseAttrs = getBaseAttributes(tagStr);\n  const attrs: NodeLikeAttributes = {};\n\n  for (const [key, value] of Object.entries(baseAttrs)) {\n    if (!unsafeAttrs || !unsafeAttrs?.has(toLowerCase(key))) {\n      attrs[key] = value;\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Converts a string to lowercase.\n * @param str The string to convert.\n * @returns The lowercase string.\n */\nexport const toLowerCase = (str: string): string => str.toLowerCase();\n\n/**\n * Converts a string to uppercase.\n * @param str The string to convert.\n * @returns The uppercase string.\n */\nexport const toUpperCase = (str: string): string => str.toUpperCase();\n\n/**\n * Checks if a string starts with a specified prefix.\n * @param str The string to check.\n * @param prefix The prefix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string starts with the prefix, `false` otherwise.\n */\nexport const startsWith = (\n  str: string,\n  prefix: string,\n  position?: number,\n): boolean => str.startsWith(prefix, position);\n\n/**\n * Checks if a string ends with a specified suffix.\n * @param str The string to check.\n * @param suffix The suffix to search for.\n * @param position The position to start looking from.\n * @returns `true` if the string ends with the suffix, `false` otherwise.\n */\nexport const endsWith = (\n  str: string,\n  suffix: string,\n  position?: number,\n): boolean => str.endsWith(suffix, position);\n\n/**\n * Creates a string from a character code.\n * @param char The character code.\n * @returns The string representation of the character code.\n */\nexport const fromCharCode = (char: number): string => String.fromCharCode(char);\n\n/**\n * Returns the character code at a specific index in a string.\n * @param str The string to check.\n * @param index The index of the character to get the code for.\n * @returns The character code at the specified index.\n */\nexport const charCodeAt = (str: string, index: number): number =>\n  str.charCodeAt(index);\n\n/**\n * Defines a property on an object.\n * @param obj The object to define the property on.\n * @param propName The name of the property.\n * @param desc The property descriptor.\n * @returns The object after defining the property.\n */\n// export const defineProperty = <T extends Record<string, unknown>>(\n//   obj: T,\n//   propName: PropertyKey,\n//   desc: PropertyDescriptor,\n// ): T => Object.defineProperty(obj, propName, desc);\n\n/**\n * Defines multiple properties on an object.\n * @param obj The object to define properties on.\n * @param props An object where keys are property names and values are property descriptors.\n * @returns The object after defining the properties.\n */\nexport const defineProperties = <T extends Record<string, unknown>>(\n  obj: T,\n  props: Record<PropertyKey, PropertyDescriptor>,\n): T => Object.defineProperties(obj, props);\n\n// Type guards\n\n/**\n * Checks if a node is an object.\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isObj = (node: unknown) =>\n  node !== null && typeof node === \"object\";\n\n/**\n * Checks if a node is a root object (`RootNode` or `RootLike`).\n * @param node The object to check.\n * @returns `true` if the node is an object, `false` otherwise.\n */\nexport const isRoot = (\n  node: RootLike | RootNode | ChildLike | ChildNode,\n): node is RootLike | RootNode =>\n  isObj(node) && isNode(node as unknown as ChildLike) &&\n  node.nodeName === \"#document\";\n\n/**\n * Checks if a node is a tag node (`NodeLike` or `DOMNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isTag = (\n  node: ChildLike | ChildNode,\n): node is NodeLike | DOMNode => isObj(node) && \"tagName\" in node;\n\n/**\n * Checks if a node is a root node (`RootLike` or `RootNode`),\n * a tag node (`NodeLike` or `DOMNode`), a comment node\n * (`CommentLike` or `CommentNode`) or text node (`TextLike` or `TextNode`).\n * @param node The node to check.\n * @returns `true` if the node is a tag node, `false` otherwise.\n */\nexport const isNode = (\n  node: ChildLike | ChildNode | NodeLikeAttributes | string | number,\n): node is ChildLike | NodeLike | DOMNode => isObj(node) && \"nodeName\" in node;\n\n/**\n * Checks if a value is a primitive (number or string).\n * @param val The value to check.\n * @returns `true` if the value is a primitive, `false` otherwise.\n */\nexport const isPrimitive = <T extends (number | string)>(\n  val: unknown,\n): val is T => typeof val === \"string\" || typeof val === \"number\";\n\n/**\n * Trim a string value.\n * @param str A string value\n * @returns The trimmed value of the same string.\n */\nexport const trim = (str: string) => str.trim();\n\n/**\n * Set of self-closing HTML tags used by the `Parser`.\n */\nexport const selfClosingTags = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n  \"path\",\n  \"circle\",\n  \"ellipse\",\n  \"line\",\n  \"rect\",\n  \"use\",\n  \"stop\",\n  \"polygon\",\n  \"polyline\",\n]);\n\n/**\n * Tokenizes an HTML string into an array of HTML tokens.\n * These tokens represent opening tags, closing tags, text content, and comments.\n * @param html The HTML string to tokenize.\n * @returns An array of `HTMLToken` objects.\n */\nexport const tokenize = (html: string): HTMLToken[] => {\n  const specialTags = [\"script\", \"style\"];\n  const tokens: HTMLToken[] = [];\n  const len = html.length;\n  let token = \"\",\n    inTag = false,\n    inQuote = false,\n    quote = 0,\n    inTemplate = false,\n    inComment = false,\n    inStyleScript = false;\n\n  for (let i = 0; i < len; i++) {\n    const char = charCodeAt(html, i);\n\n    if (inComment) {\n      token += fromCharCode(char);\n      /* istanbul ignore else @preserve */\n      if (endsWith(token, \"--\") && charCodeAt(html, i + 1) === 62 /* > */) {\n        tokens.push({\n          nodeType: \"comment\",\n          value: `<${trim(token)}>`,\n          isSC: false,\n        });\n        inComment = false;\n        token = \"\";\n        i += 1;\n      }\n      continue;\n    }\n\n    if (inStyleScript) {\n      const endSpecialTag = specialTags.find((t) =>\n        startsWith(html, `/${t}`, i + 1)\n      );\n      if (char === 60 && endSpecialTag && !inTag && !inTemplate && !inQuote) { // <\n        inStyleScript = false;\n      }\n      // console.log('277', {char: html[i], token, inStyleScript })\n      if (char === 96) { // ` | 0x60\n        inTemplate = !inTemplate;\n      }\n    }\n\n    // \" or ' | 0x22 or 0x27\n    if (\n      (inTag || inStyleScript) && (char === 34 || char === 39)\n    ) {\n      if (!inQuote) {\n        quote = char;\n        inQuote = true;\n      } else if (char === quote) {\n        inQuote = false;\n      }\n\n      token += fromCharCode(char);\n      continue;\n    }\n\n    // else\n    if (char === 60 && !inQuote && !inTemplate && !inStyleScript) { // <\n      trim(token) &&\n        tokens.push({\n          nodeType: \"text\",\n          value: trim(token),\n          isSC: false,\n        });\n      token = \"\";\n      inTag = true;\n\n      if (startsWith(html, \"!--\", i + 1)) {\n        inComment = true;\n        token += \"!--\";\n        i += 3;\n        continue;\n      }\n    } else if (\n      char === 62 && inTag && !inQuote && !inTemplate && !inComment &&\n      !inStyleScript\n    ) { // >\n      const startSpecialTag = specialTags.find((t) =>\n        t === token || startsWith(token, t)\n      );\n      if (startSpecialTag) {\n        inStyleScript = true;\n      }\n      // handle doctype tag\n      const isDocType = startsWith(toLowerCase(token), \"!doctype\");\n      /* istanbul ignore else @preserve */\n      if (token) {\n        const isSC = endsWith(token, \"/\");\n        tokens.push({\n          nodeType: isDocType ? \"doctype\" : \"tag\",\n          value: isSC ? trim(token.slice(0, -1)) : trim(token),\n          isSC,\n        });\n      }\n      token = \"\";\n      inTag = false;\n    } else {\n      token += fromCharCode(char);\n    }\n  }\n\n  trim(token) &&\n    tokens.push({ nodeType: \"text\", value: trim(token), isSC: false });\n\n  return tokens;\n};\n\nexport const DOM_ERROR = \"DomParserError:\";\n","// selectors.ts\nimport { startsWith, toLowerCase } from \"./util.ts\";\nimport type { DOMNode, MatchFunction, SelectorPart } from \"./types.ts\";\n\n/**\n * Create a selector cache to help improve `match` based queries\n * (querySelector, querySelectorAll).\n */\nclass SelectorCacheMap extends Map<string, MatchFunction> {\n  private hits = 0;\n  private misses = 0;\n\n  constructor() {\n    super();\n    this.misses = 0;\n    this.hits = 0;\n  }\n  hit() {\n    this.hits += 1;\n  }\n  miss() {\n    this.hits += 1;\n  }\n  getMatchFunction(selector: string, maxSize = 100): MatchFunction {\n    let matchFn = this.get(selector);\n\n    if (!matchFn) {\n      this.miss();\n      // If cache is full, remove oldest entry\n      if (this.size >= maxSize) {\n        const firstKey = this.keys().next().value;\n        /* istanbul ignore else @preserve */\n        if (firstKey) this.delete(firstKey);\n      }\n\n      // Parse selector parts once and create a matcher function\n      const parts = selector.split(\",\").map((s) => s.trim());\n\n      matchFn = (node: DOMNode): boolean =>\n        parts.some((part) => matchesSingleSelector(node, part));\n\n      this.set(selector, matchFn);\n    } else {\n      this.hit();\n    }\n\n    return matchFn;\n  }\n  clear() {\n    super.clear();\n    this.misses = 0;\n    this.hits = 0;\n  }\n  getStats() {\n    return {\n      size: this.size,\n      hits: this.hits,\n      misses: this.misses,\n      // prevent division by ZERO\n      hitRate: this.hits / ((this.hits + this.misses) || 1),\n    };\n  }\n}\n\nexport const selectorCache = new SelectorCacheMap();\n\n// Selector RegExp\nconst SELECTOR_REGEX = /([.#]?[\\w-]+|\\[[\\w-]+(?:=[^\\]]+)?\\])+/g;\n\n/**\n * Parses a CSS selector string into an array of selector parts.\n * Each part represents a segment of the selector (e.g., tag name, class, id, attribute).\n * @param selector The CSS selector string to parse.\n * @returns An array of `SelectorPart` objects representing the parsed selector.\n */\nconst parseSelector = (selector: string): SelectorPart[] => {\n  const parts: SelectorPart[] = [];\n  const matches =\n    selector.match(SELECTOR_REGEX) || /* istanbul ignore next @preserve */ [];\n\n  for (const match of matches) {\n    if (startsWith(match, \"#\")) {\n      parts.push({ type: \"#\", name: \"id\", value: match.slice(1) });\n    } else if (startsWith(match, \".\")) {\n      parts.push({ type: \".\", name: \"class\", value: match.slice(1) });\n    } else if (startsWith(match, \"[\")) {\n      const [name, value] = match.slice(1, -1).split(\"=\");\n      parts.push({\n        type: \"[\",\n        name,\n        value: value ? value.replace(/['\"]/g, \"\") : undefined,\n      });\n    } else {\n      parts.push({ type: \"\", name: match });\n    }\n  }\n  return parts;\n};\n\n/**\n * Checks if a node matches a single CSS selector.\n * @param node The `DOMNode` object to test against the selector.\n * @param selector The CSS selector string.\n * @returns `true` if the node matches the selector, `false` otherwise.\n */\nconst matchesSingleSelector = (node: DOMNode, selector: string): boolean => {\n  const parts = parseSelector(selector);\n\n  return parts.every((part) => {\n    switch (part.type) {\n      case \"#\": {\n        return node.attributes.get(\"id\") === part.value;\n      }\n      case \".\": {\n        const classes = node.attributes.get(\"class\")?.split(/\\s+/) || [];\n        return classes.includes(part.value as string);\n      }\n      case \"[\": {\n        const attrValue = node.attributes.get(part.name);\n        return part.value ? attrValue === part.value : attrValue !== undefined;\n      }\n      default: {\n        return toLowerCase(node.tagName) === toLowerCase(part.name);\n      }\n    }\n  });\n};\n\n/**\n * Checks if a node matches one or mode CSS selectors.\n * @param node The `DOMNode` object to test against the selector.\n * @param selector The CSS selector string.\n * @returns `true` if the node matches the selector, `false` otherwise.\n */\nexport const matchesSelector = (node: DOMNode, selector: string): boolean => {\n  const matcher = selectorCache.getMatchFunction(selector);\n  return matcher(node);\n};\n","// prototype.ts\n// import { tokenize } from \"./dom-parser.ts\";\nimport { tokenize } from \"./util.ts\";\nimport { matchesSelector } from \"./selectors.ts\";\nimport {\n  defineProperties,\n  DOM_ERROR,\n  isNode,\n  isObj,\n  isPrimitive,\n  isRoot,\n  isTag,\n  selfClosingTags,\n  toUpperCase,\n} from \"./util.ts\";\n\nimport type {\n  ChildElementList,\n  ChildNode,\n  ChildNodeList,\n  CommentNode,\n  DOMNode,\n  MaybeChildNode,\n  NodeLikeAttributes,\n  RootNode,\n  TagNames,\n  TextNode,\n  TextToken,\n} from \"./types.ts\";\n\n/**\n * Generates text string from node's children textContent.\n * @param node The node whose children to stringify\n * @returns textContent string\n */\nconst textContent = (node: ChildNode): string => {\n  if (!isTag(node)) return node.nodeValue;\n  const { childNodes } = node;\n  if (!childNodes.length) return \"\";\n\n  return childNodes.map((n) =>\n    isTag(n) ? textContent(n as unknown as DOMNode) : n.nodeValue\n  ).join(\"\\n\");\n};\n\n/**\n * Generates HTML string for node's children\n * @param node The node whose children to stringify\n * @param depth Current indentation depth\n * @returns innerHTML string\n */\nconst innerHTML = ({ childNodes }: DOMNode, depth = 0): string => {\n  if (!childNodes.length) return \"\";\n\n  const childIsText = childNodes.length === 1 && !isTag(childNodes[0]);\n  const space = depth && !childIsText ? \"  \".repeat(depth) : \"\";\n\n  return childNodes\n    .map((n) =>\n      isTag(n) ? outerHTML(n as unknown as DOMNode, depth) : space + n.nodeValue\n    )\n    .join(\"\\n\");\n};\n\n/**\n * Generates HTML string for a node including its opening/closing tags\n * @param node The node to stringify\n * @param depth Current indentation depth\n * @returns outerHTML string\n */\nconst outerHTML = (node: DOMNode, depth = 0): string => {\n  const space = depth ? \"  \".repeat(depth) : \"\";\n  const { attributes, tagName, childNodes } = node;\n  const hasChildren = childNodes.length > 0;\n  const childIsText = childNodes.length === 1 && !isTag(childNodes[0]);\n  const hasAttributes = attributes.size > 0;\n  const isSelfClosing = selfClosingTags.has(tagName);\n\n  const attrStr = hasAttributes\n    ? \" \" + Array.from(attributes)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .join(\" \")\n    : \"\";\n\n  // add doctype?\n  // let output = tagName === \"html\" ? \"<!doctype html>\\n\" : \"\";\n  let output = `${space}<${tagName}${attrStr}${isSelfClosing ? \" /\" : \"\"}>`;\n  output += hasChildren && !childIsText ? \"\\n\" : \"\";\n  output += hasChildren ? innerHTML(node, depth + 1) : \"\";\n  output += !childIsText && hasChildren ? `\\n${space}` : \"\";\n  output += !isSelfClosing ? `</${tagName}>` : \"\";\n\n  return output;\n};\n\n/**\n * Creates a basic text or comment node.\n * @param nodeName The node name (\"#text\" or \"#comment\").\n * @param text The text content of the node.\n * @returns A TextNode or CommentNode object.\n */\nexport function createBasicNode<T extends (\"#text\" | \"#comment\")>(\n  nodeName: T,\n  text: string,\n): TextNode | CommentNode {\n  return {\n    nodeName,\n    // nodeValue: nodeName !== \"#text\" ? `<!-- ${text} -->` : text,\n    nodeValue: nodeName !== \"#text\" ? `<${text}>` : text,\n  } as (TextNode | CommentNode);\n}\n\n/**\n * Creates a DOM-like Node (`DOMNode` or `RootNode`) with DOM API extensions and sanitization.\n * This function extends the basic `NodeLike` from **Parser** by adding DOM-specific properties and methods,\n * as well as applying sanitization based on the provided configuration.\n *\n * @param this - The `RootNode` when creating a `DOMNode`, or `null` otherwise (in non-strict mode)\n * @param nodeName The tag name of the node to create (or '#document' for the root).\n * @param childNodes Optional child nodes to append to the created node.\n * @returns An extended `DOMNode` or `RootNode` object with DOM API.\n */\nexport function createNode(\n  this: RootNode | null,\n  nodeName: string,\n  ...childNodes: ChildNodeList\n): Omit<DOMNode, \"tagName\" | \"attributes\"> | RootNode {\n  const ALL: ChildElementList = [];\n  const CHILDREN: ChildElementList = [];\n  const CHILDNODES: ChildNodeList = [];\n  const nodeIsRoot = nodeName === \"#document\";\n  const ownerDocument = this ?? undefined;\n\n  const node = {\n    nodeName,\n    append(...nodes: ChildNodeList) {\n      for (const child of nodes) {\n        if (!isNode(child)) {\n          throw new Error(`${DOM_ERROR} Invalid node.`);\n        }\n        CHILDNODES.push(child);\n        if (isTag(child)) {\n          ALL.push(child);\n          CHILDREN.push(child);\n          ownerDocument?.register(child);\n\n          // Add HTML generation methods\n          defineProperties(child, {\n            innerHTML: {\n              enumerable: false,\n              get: () => innerHTML(child),\n            },\n            outerHTML: {\n              enumerable: false,\n              get: () => outerHTML(child),\n            },\n          });\n        }\n\n        defineProperties(child, {\n          // Add text generation methods\n          textContent: {\n            enumerable: false,\n            get: () => textContent(child),\n          },\n          // Add node relationship properties\n          parentNode: {\n            enumerable: false,\n            get: () => node,\n          },\n          parentElement: {\n            enumerable: false,\n            get: () => node,\n          },\n          ownerDocument: {\n            enumerable: false,\n            get: () => ownerDocument,\n          },\n        });\n\n        child.remove = () => {\n          node.removeChild(child);\n        };\n      }\n    },\n    cleanup: () => {\n      ALL.length = 0;\n      CHILDREN.length = 0;\n      CHILDNODES.length = 0;\n    },\n\n    // Root document methods\n    ...(isRoot({ nodeName } as RootNode) && {\n      createElement(\n        tagName:\n          & string\n          & (keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap),\n        first?: NodeLikeAttributes | MaybeChildNode,\n        ...rest: MaybeChildNode[]\n      ) {\n        return createElement.call(\n          node as RootNode,\n          tagName,\n          first,\n          ...rest,\n        );\n      },\n      createElementNS(\n        _ns: string,\n        tagName:\n          & string\n          & (keyof SVGElementTagNameMap & keyof HTMLElementTagNameMap),\n        first?: NodeLikeAttributes | MaybeChildNode,\n        ...rest: MaybeChildNode[]\n      ) {\n        return createElement.call(node as RootNode, tagName, first, ...rest);\n      },\n      createComment(content: string) {\n        return createBasicNode(\"#comment\", content);\n      },\n      createTextNode(content: string) {\n        return createBasicNode(\"#text\", content);\n      },\n      getElementById(id: string) {\n        return ALL.find((node) => node.attributes.get(\"id\") === id) ?? null;\n      },\n    }),\n\n    // Element methods\n    ...((!nodeIsRoot) && {\n      matches(selector: string) {\n        return matchesSelector(node as unknown as DOMNode, selector);\n      },\n    }),\n    // Shared methods\n    contains: (childNode: DOMNode) => {\n      if (!childNode || !isTag(childNode)) {\n        throw new Error(\n          \"DomError: the childNode parameter must be a valid DOMNode\",\n        );\n      }\n      if ((node as DOMNode | RootNode).children.includes(childNode)) {\n        return true;\n      }\n\n      let currentParent = childNode.parentNode;\n      while (currentParent) {\n        if (currentParent === node) {\n          return true;\n        }\n        currentParent = currentParent.parentNode;\n      }\n      return false;\n    },\n    removeChild(childNode: ChildNode) {\n      if (!childNode || !isNode(childNode)) {\n        throw new Error(\n          \"DomError: the childNode parameter must be a valid ChildNode\",\n        );\n      }\n\n      const indexOf = (arr: ChildNode[]) => arr.indexOf(childNode);\n      /* istanbul ignore else @preserve */\n      if (isTag(childNode)) {\n        const idx1 = indexOf(ALL);\n        const idx2 = indexOf(CHILDREN);\n        /* istanbul ignore else @preserve */\n        if (idx1 > -1) ALL.splice(idx1, 1);\n        /* istanbul ignore else @preserve */\n        if (idx2 > -1) CHILDREN.splice(idx2, 1);\n        childNode.cleanup();\n\n        ownerDocument?.deregister(childNode);\n      }\n\n      const idx3 = indexOf(CHILDNODES);\n      /* istanbul ignore else @preserve */\n      if (idx3 > -1) CHILDNODES.splice(idx3, 1);\n    },\n    replaceChildren: (...newChildren: DOMNode[]) => {\n      // clone this array to work\n      CHILDNODES.slice(0).forEach((childNode) => node.removeChild(childNode));\n      node.append(...newChildren);\n    },\n    querySelector(selector: string) {\n      return ALL.find((node) => node.matches(selector)) ?? null;\n    },\n    querySelectorAll(selector: string) {\n      return ALL.filter((node) => node.matches(selector));\n    },\n    getElementsByTagName(tagName: string) {\n      return tagName === \"*\"\n        ? ALL\n        : ALL.filter((node) =>\n          node.tagName.toLowerCase() === tagName.toLowerCase()\n        );\n    },\n    getElementsByClassName(className: string) {\n      return ALL.filter((node) => {\n        const classAttr = node.attributes.get(\"class\");\n        return classAttr?.split(/\\s+/).includes(className) ?? false;\n      });\n    },\n  };\n\n  // Define enumerable getters\n  defineProperties(node, {\n    childNodes: {\n      enumerable: true,\n      get: () => CHILDNODES,\n    },\n    children: {\n      enumerable: true,\n      get: () => CHILDREN,\n    },\n  });\n\n  // Add root-specific properties\n  if (nodeIsRoot) {\n    defineProperties(node, {\n      all: {\n        enumerable: true,\n        get: () => ALL,\n      },\n      documentElement: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"HTML\"),\n      },\n      head: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"HEAD\"),\n      },\n      body: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"BODY\"),\n      },\n      register: {\n        enumerable: false,\n        value: (child: DOMNode) => {\n          ALL.push(child);\n        },\n      },\n      deregister: {\n        enumerable: false,\n        value: (child: DOMNode) => {\n          const idx = ALL.indexOf(child);\n          /* istanbul ignore else @preserve */\n          if (idx > -1) ALL.splice(idx, 1);\n        },\n      },\n    });\n  }\n\n  // Add any initial children\n  if (childNodes?.length) {\n    node.append(...childNodes);\n  }\n\n  return node as unknown as RootNode | Omit<DOMNode, \"tagName\" | \"attributes\">;\n}\n\nconst convertToNode = (n: string | number | ChildNode) => {\n  if (isPrimitive(n)) {\n    const { nodeType, value } = tokenize(String(n))[0] as TextToken;\n    // return createBasicNode(`#${nodeType}`, value.replace(/!--|--/g, \"\").trim());\n    return createBasicNode(`#${nodeType}`, value);\n  }\n  return n;\n};\n\n/**\n * Creates a new `Element` like node\n * @param this The RootNode instance\n * @param tagName Tag name for the element\n * @param first Optional attributes or first child\n * @param args Additional child nodes\n * @returns New element node\n */\nexport function createElement(\n  this: RootNode,\n  tagName: string & TagNames,\n  first?: NodeLikeAttributes | MaybeChildNode,\n  ...args: MaybeChildNode[]\n): DOMNode {\n  const childNodes: ChildNodeList = [];\n  let attributes = new Map<string, string>();\n\n  // Handle first argument\n  /* istanbul ignore else @preserve */\n  if (first) {\n    if (isObj(first) && !isNode(first)) {\n      // Convert attributes object to Map\n      attributes = new Map(Object.entries(first));\n    } else {\n      childNodes.push(convertToNode(first as string | number | ChildNode));\n    }\n  }\n\n  // Add remaining children\n  const nodes = args.map(convertToNode).filter(isNode);\n  childNodes.push(...nodes);\n\n  const node = createNode.call(\n    this,\n    toUpperCase(tagName),\n    ...childNodes,\n  ) as DOMNode;\n\n  const charset = attributes.get(\"charset\");\n  if (tagName === \"meta\" && charset) {\n    this.charset = toUpperCase(charset);\n  }\n\n  defineProperties(node, {\n    tagName: {\n      enumerable: true,\n      get: () => tagName,\n    },\n    attributes: {\n      enumerable: true,\n      get: () => attributes,\n    },\n  });\n  // define Element attributes methods\n  node.hasAttribute = (attrName) => attributes.has(attrName);\n  node.getAttribute = (attrName) => attributes.get(attrName) ?? null;\n  node.setAttribute = (attrName, attrValue) => {\n    attributes.set(attrName, attrValue);\n  };\n  node.hasAttributeNS = (_namespace, attrName) => attributes.has(attrName);\n  node.getAttributeNS = (_namespace, attrName) =>\n    attributes.get(attrName) ?? null;\n  node.setAttributeNS = (_namespace, attrName, attrValue) => {\n    attributes.set(attrName, attrValue);\n  };\n  // define Element parent selector\n  node.closest = (selector: string) => {\n    if (!selector) throw new Error(\"DomError: selector must be a string\");\n    if (node.matches(selector)) return node;\n    let currentParent = node.parentNode;\n    while (!isRoot(currentParent)) {\n      if (currentParent.matches(selector)) {\n        return currentParent;\n      }\n      currentParent = currentParent.parentNode;\n    }\n    return null;\n  };\n\n  return node;\n}\n\n/**\n * Creates a new `Document` like root node.\n *\n * @returns a new root node\n */\nexport const createDocument = () =>\n  createNode.call(null, \"#document\") as RootNode;\n","// dom.ts\nimport { createBasicNode, createDocument, createElement } from \"./prototype.ts\";\nimport { DOM_ERROR, isObj } from \"./util.ts\";\nimport type {\n  ChildNode,\n  DomParserOptions,\n  DomParserResult,\n  RootNode,\n} from \"./types.ts\";\n\nimport type { DOMNode, GetAttributesOptions } from \"./types.ts\";\n\nimport {\n  getAttributes,\n  selfClosingTags,\n  startsWith,\n  toLowerCase,\n  toUpperCase,\n} from \"./util.ts\";\n\nimport { tokenize } from \"./util.ts\";\n\n/**\n * **DomParser**\n *\n * Unlike the basic **Parser**, **DomParser** creates a new `Document` like instance with DOM-like\n * methods and properties and populates it with `Node` like objects resulted from the parsing\n * of a given HTML markup.\n *\n * **Features**\n * * The **DomParser** is ~2Kb gZipped and has additional features compared to the basic **Parser**.\n * * It handles basic HTML elements, custom elements, UI frameworks components,\n * special attributes, and text and comment nodes.\n * * It allows you to filter tags and unsafe attributes; _by default the filters are empty_.\n *\n * The DOM representation is a plain object with the following structure:\n * ```ts\n *  type TextNode = {\n *   nodeName: \"#text\";\n *   ownerDocument: RootNode;\n *   parentNode: RootNode | DOMNode;\n *   textContent: string;\n *   nodeValue: string;\n *   remove: () => void;\n * };\n *  type DOMNode = {\n *   tagName: string;\n *   nodeName: string;\n *   textContent: string;\n *   innerHTML: string;\n *   outerHTML: string;\n *   attributes: Map<string, string>;\n *   hasAttribute: (attrName: string) => boolean;\n *   getAttribute: (attrName: string) => string;\n *   setAttribute: (attrName: string, attrValue: string) => void;\n *   hasAttributeNS: (ns: string, attrName: string) => boolean;\n *   getAttributeNS: (ns: string, attrName: string) => string;\n *   setAttributeNS: (ns: string, attrName: string, attrValue: string) => void;\n *   remove: () => void;\n *   cleanup: () => void;\n *   removeChild: (childNode: DOMNode | TextNode | CommentNode) => void;\n *   append: (childNode: DOMNode | TextNode | CommentNode) => void;\n *   replaceChildren: (...newChildren: DOMNode[]) => void;\n *   children: DOMNode[];\n *   childNodes: (DOMNode | TextNode | CommentNode)[];\n *   contains: (childNode: DOMNode) => boolean;\n *   matches: (selector: string) => boolean;\n *   closest: (selector: string) => DOMNode | null;\n *   ownerDocument: RootNode;\n *   parentNode: RootNode | DOMNode;\n *   querySelector: (selector: string) => DOMNode | null;\n *   querySelectorAll: (selector: string) => DOMNode[];\n *   getElementsByClassName: (className: string) => DOMNode[];\n *   getElementsByTagName: (tagName: string) => DOMNode[];\n * };\n *\n *  // this is the return of DomParser()\n *  type RootNode = {\n *   nodeName: string;\n *   doctype?: string;\n *   charset?: string;\n *   documentElement: DOMNode | null;\n *   head: DOMNode | null;\n *   body: DOMNode | null;\n *   all: DOMNode[];\n *   children: DOMNode[];\n *   childNodes: (DOMNode | TextNode | CommentNode)[];\n *   createElement: (tagName: string, first: Attributes | DOMNode, ...childNodes: (DOMNode | TextNode)[]);\n *   createElementNS: (ns: string, tagName: string, first: Attributes | DOMNode, ...childNodes: (DOMNode | TextNode)[]);\n *   createTextNode: (content: string) => TextNode;\n *   createComment: (content: string) => CommentNode;\n *   cleanup: () => void;\n *   removeChild: (childNode: DOMNode | TextNode | CommentNode) => void;\n *   replaceChildren: (...newChildren: DOMNode[]) => void;\n *   append: (childNode: DOMNode | TextNode | CommentNode) => void;\n *   contains: (childNode: DOMNode) => boolean;\n *   getElementById: (id: string) => DOMNode | null;\n *   querySelector: (selector: string) => DOMNode | null;\n *   querySelectorAll: (selector: string) => DOMNode[];\n *   getElementsByClassName: (className: string) => DOMNode[];\n *   getElementsByTagName: (tagName: string) => DOMNode[];\n *   register: (node: DOMNode) => void;\n *   deregister: (node: DOMNode) => void;\n * };\n * ```\n *\n * @example\n * ```ts\n * const config = {\n *   // On creating new node callback function\n *   onNodeCallback?: myFunction(node: DOMNode) => DOMNode | YOURNode,\n *   // Common dangerous tags that could lead to XSS attacks\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS attacks\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const { root: doc, components, tags } = DomParser.parseFromString(\"<!doctype html><html>This is starting html</html>\", config);\n * console.log(doc.documentElement.outerHTML);\n * // > \"<html>This is starting html</html>\"\n * ```\n *\n * @param startHTML Initial HTML content\n * @param config the `Parser` options to apply to the parsing of the startHTML markup.\n * @returns The `Document` like root node\n */\nexport const DomParser = (\n  config?: Partial<DomParserOptions>,\n) => {\n  if (config && !isObj(config)) {\n    throw new Error(`${DOM_ERROR} 1st parameter is not an object.`);\n  }\n\n  // Common dangerous tags that could lead to XSS\n  let unsafeTags = new Set<string>();\n\n  // Unsafe attributes that could lead to XSS\n  let unsafeAttrs = new Set<string>();\n\n  // Apply config\n  const { filterTags, filterAttrs, onNodeCallback } = config || {};\n  if (filterTags?.length) unsafeTags = new Set(filterTags);\n  if (filterAttrs?.length) unsafeAttrs = new Set(filterAttrs);\n  const getAttrOptions = { unsafeAttrs } as GetAttributesOptions;\n  // don't override the default function unless it's actualy set\n\n  return {\n    parseFromString(htmlString?: string) {\n      if (htmlString && typeof htmlString !== \"string\") {\n        throw new Error(`${DOM_ERROR} 1st parameter is not a string.`);\n      }\n      const root = createDocument();\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack: (RootNode | DOMNode)[] = [root];\n      const tagStack: string[] = [];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      let parentIsSafe = true;\n      let newNode: ChildNode;\n\n      tokenize(htmlString).forEach((token) => {\n        console.log(token);\n        const { nodeType, value, isSC } = token;\n        // Skip doctype, but store it as a root property\n        if (nodeType === \"doctype\") {\n          root.doctype = `<${value}>`;\n          return;\n        }\n        const currentParent = stack[stack.length - 1];\n\n        if ([\"text\", \"comment\"].includes(nodeType)) {\n          newNode = createBasicNode(\n            `#${nodeType as \"text\" | \"comment\"}`,\n            value,\n          ) as ChildNode;\n          currentParent.append(newNode);\n          return;\n        }\n\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const tagNameLower = toLowerCase(tagName);\n        const isSelfClosing = isSC || selfClosingTags.has(tagNameLower);\n\n        // Tag Matching Detection Logic\n        if (!isSelfClosing) {\n          // Start Tag (and not self-closing)\n          if (!isClosing) {\n            // Push tag name onto the tag stack\n            tagStack.push(tagName);\n            // Closing Tag\n          } else {\n            // Pop the last opened tag\n            const expectedTag = tagStack.pop();\n            if (expectedTag !== tagName) {\n              if (expectedTag === undefined) {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. No open tag found.`,\n                );\n              } else {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. Expected closing tag for <${expectedTag}>.`,\n                );\n              }\n            }\n          }\n        }\n\n        // Skip unsafe tags\n        if (unsafeTags.has(tagNameLower)) {\n          if (isClosing) {\n            parentIsSafe = true;\n          } else {\n            parentIsSafe = false;\n          }\n          return;\n        }\n\n        if (!parentIsSafe) return;\n\n        // Register tag/component type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const attributes = getAttributes(value, getAttrOptions);\n          newNode = createElement.call(\n            root,\n            tagName as DOMNode[\"tagName\"],\n            attributes,\n          ) as DOMNode;\n          if (onNodeCallback) onNodeCallback(newNode, currentParent, root);\n\n          const charset = attributes?.charset;\n          if (tagName === \"meta\" && charset) {\n            root.charset = toUpperCase(charset);\n          }\n\n          currentParent.append(newNode);\n          !isSelfClosing && stack.push(newNode);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      });\n\n      // Check for unclosed tags at the end\n      // an edge case where end tag is malformed `</incomplete`\n      if (tagStack.length > 0) {\n        const unclosedTag = tagStack.pop();\n        throw new Error(`${DOM_ERROR} Unclosed tag: <${unclosedTag}>.`);\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies DomParserResult;\n    },\n  };\n};\n"]}