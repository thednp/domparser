{"version":3,"sources":["/home/artae/Work/Github/domparser/dist/chunk-R4DWLBYH.cjs","../src/parts/selectors.ts","../src/parts/prototype.ts"],"names":[],"mappings":"AAAA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACF,wDAA6B;AAC7B;AACA;ACRA,IAAM,iBAAA,EAAN,MAAA,QAA+B,IAA2B;AAAA,EAIxD,WAAA,CAAA,EAAc;AACZ,IAAA,KAAA,CAAM,CAAA;AAJR,IAAA,6CAAA,IAAA,EAAQ,MAAA,EAAO,CAAA,CAAA;AACf,IAAA,6CAAA,IAAA,EAAQ,QAAA,EAAS,CAAA,CAAA;AAIf,IAAA,IAAA,CAAK,OAAA,EAAS,CAAA;AACd,IAAA,IAAA,CAAK,KAAA,EAAO,CAAA;AAAA,EACd;AAAA,EACA,GAAA,CAAA,EAAM;AACJ,IAAA,IAAA,CAAK,KAAA,GAAQ,CAAA;AAAA,EACf;AAAA,EACA,IAAA,CAAA,EAAO;AACL,IAAA,IAAA,CAAK,KAAA,GAAQ,CAAA;AAAA,EACf;AAAA,EACA,gBAAA,CAAiB,QAAA,EAAkB,QAAA,EAAU,GAAA,EAAoB;AAC/D,IAAA,IAAI,QAAA,EAAU,IAAA,CAAK,GAAA,CAAI,QAAQ,CAAA;AAE/B,IAAA,GAAA,CAAI,CAAC,OAAA,EAAS;AACZ,MAAA,IAAA,CAAK,IAAA,CAAK,CAAA;AAEV,MAAA,GAAA,CAAI,IAAA,CAAK,KAAA,GAAQ,OAAA,EAAS;AACxB,QAAA,MAAM,SAAA,EAAW,IAAA,CAAK,IAAA,CAAK,CAAA,CAAE,IAAA,CAAK,CAAA,CAAE,KAAA;AAEpC,QAAA,GAAA,CAAI,QAAA,EAAU,IAAA,CAAK,MAAA,CAAO,QAAQ,CAAA;AAAA,MACpC;AAGA,MAAA,MAAM,MAAA,EAAQ,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,CAAI,CAAC,CAAA,EAAA,GAAM,CAAA,CAAE,IAAA,CAAK,CAAC,CAAA;AAErD,MAAA,QAAA,EAAU,CAAC,IAAA,EAAA,GACT,KAAA,CAAM,IAAA,CAAK,CAAC,IAAA,EAAA,GAAS,qBAAA,CAAsB,IAAA,EAAM,IAAI,CAAC,CAAA;AAExD,MAAA,IAAA,CAAK,GAAA,CAAI,QAAA,EAAU,OAAO,CAAA;AAAA,IAC5B,EAAA,KAAO;AACL,MAAA,IAAA,CAAK,GAAA,CAAI,CAAA;AAAA,IACX;AAEA,IAAA,OAAO,OAAA;AAAA,EACT;AAAA,EACA,KAAA,CAAA,EAAQ;AACN,IAAA,KAAA,CAAM,KAAA,CAAM,CAAA;AACZ,IAAA,IAAA,CAAK,OAAA,EAAS,CAAA;AACd,IAAA,IAAA,CAAK,KAAA,EAAO,CAAA;AAAA,EACd;AAAA,EACA,QAAA,CAAA,EAAW;AACT,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,IAAA,CAAK,IAAA;AAAA,MACX,IAAA,EAAM,IAAA,CAAK,IAAA;AAAA,MACX,MAAA,EAAQ,IAAA,CAAK,MAAA;AAAA;AAAA,MAEb,OAAA,EAAS,IAAA,CAAK,KAAA,EAAA,CAAS,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,OAAA,GAAW,CAAA;AAAA,IACrD,CAAA;AAAA,EACF;AACF,CAAA;AAEO,IAAM,cAAA,EAAgB,IAAI,gBAAA,CAAiB,CAAA;AAGlD,IAAM,eAAA,EAAiB,wCAAA;AAQvB,IAAM,cAAA,EAAgB,CAAC,QAAA,EAAA,GAAqC;AAC1D,EAAA,MAAM,MAAA,EAAwB,CAAC,CAAA;AAC/B,EAAA,MAAM,QAAA,EACJ,QAAA,CAAS,KAAA,CAAM,cAAc,EAAA;AAAA,EAA0C,CAAC,CAAA;AAE1E,EAAA,IAAA,CAAA,MAAW,MAAA,GAAS,OAAA,EAAS;AAC3B,IAAA,GAAA,CAAI,0CAAA,KAAW,EAAO,GAAG,CAAA,EAAG;AAC1B,MAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,GAAA,EAAK,IAAA,EAAM,IAAA,EAAM,KAAA,EAAO,KAAA,CAAM,KAAA,CAAM,CAAC,EAAE,CAAC,CAAA;AAAA,IAC7D,EAAA,KAAA,GAAA,CAAW,0CAAA,KAAW,EAAO,GAAG,CAAA,EAAG;AACjC,MAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,GAAA,EAAK,IAAA,EAAM,OAAA,EAAS,KAAA,EAAO,KAAA,CAAM,KAAA,CAAM,CAAC,EAAE,CAAC,CAAA;AAAA,IAChE,EAAA,KAAA,GAAA,CAAW,0CAAA,KAAW,EAAO,GAAG,CAAA,EAAG;AACjC,MAAA,MAAM,CAAC,IAAA,EAAM,KAAK,EAAA,EAAI,KAAA,CAAM,KAAA,CAAM,CAAA,EAAG,CAAA,CAAE,CAAA,CAAE,KAAA,CAAM,GAAG,CAAA;AAClD,MAAA,KAAA,CAAM,IAAA,CAAK;AAAA,QACT,IAAA,EAAM,GAAA;AAAA,QACN,IAAA;AAAA,QACA,KAAA,EAAO,MAAA,EAAQ,KAAA,CAAM,OAAA,CAAQ,OAAA,EAAS,EAAE,EAAA,EAAI,KAAA;AAAA,MAC9C,CAAC,CAAA;AAAA,IACH,EAAA,KAAO;AACL,MAAA,KAAA,CAAM,IAAA,CAAK,EAAE,IAAA,EAAM,EAAA,EAAI,IAAA,EAAM,MAAM,CAAC,CAAA;AAAA,IACtC;AAAA,EACF;AACA,EAAA,OAAO,KAAA;AACT,CAAA;AAQA,IAAM,sBAAA,EAAwB,CAAC,IAAA,EAAe,QAAA,EAAA,GAA8B;AAC1E,EAAA,MAAM,MAAA,EAAQ,aAAA,CAAc,QAAQ,CAAA;AAEpC,EAAA,OAAO,KAAA,CAAM,KAAA,CAAM,CAAC,IAAA,EAAA,GAAS;AAC3B,IAAA,OAAA,CAAQ,IAAA,CAAK,IAAA,EAAM;AAAA,MACjB,KAAK,GAAA,EAAK;AACR,QAAA,OAAO,IAAA,CAAK,UAAA,CAAW,GAAA,CAAI,IAAI,EAAA,IAAM,IAAA,CAAK,KAAA;AAAA,MAC5C;AAAA,MACA,KAAK,GAAA,EAAK;AACR,QAAA,MAAM,QAAA,kBAAU,IAAA,mBAAK,UAAA,qBAAW,GAAA,mBAAI,OAAO,CAAA,6BAAG,KAAA,mBAAM,KAAK,IAAA,GAAK,CAAC,CAAA;AAC/D,QAAA,OAAO,OAAA,CAAQ,QAAA,CAAS,IAAA,CAAK,KAAe,CAAA;AAAA,MAC9C;AAAA,MACA,KAAK,GAAA,EAAK;AACR,QAAA,MAAM,UAAA,EAAY,IAAA,CAAK,UAAA,CAAW,GAAA,CAAI,IAAA,CAAK,IAAI,CAAA;AAC/C,QAAA,OAAO,IAAA,CAAK,MAAA,EAAQ,UAAA,IAAc,IAAA,CAAK,MAAA,EAAQ,UAAA,IAAc,KAAA,CAAA;AAAA,MAC/D;AAAA,MACA,OAAA,EAAS;AACP,QAAA,OAAO,2CAAA,IAAY,CAAK,OAAO,EAAA,IAAM,2CAAA,IAAY,CAAK,IAAI,CAAA;AAAA,MAC5D;AAAA,IACF;AAAA,EACF,CAAC,CAAA;AACH,CAAA;AAQO,IAAM,gBAAA,EAAkB,CAAC,IAAA,EAAe,QAAA,EAAA,GAA8B;AAC3E,EAAA,MAAM,QAAA,EAAU,aAAA,CAAc,gBAAA,CAAiB,QAAQ,CAAA;AACvD,EAAA,OAAO,OAAA,CAAQ,IAAI,CAAA;AACrB,CAAA;AD1BA;AACA;AE9EA,IAAM,YAAA,EAAc,CAAC,IAAA,EAAA,GAA4B;AAC/C,EAAA,GAAA,CAAI,CAAC,qCAAA,IAAU,CAAA,EAAG,OAAO,IAAA,CAAK,SAAA;AAC9B,EAAA,MAAM,EAAE,WAAW,EAAA,EAAI,IAAA;AACvB,EAAA,GAAA,CAAI,CAAC,UAAA,CAAW,MAAA,EAAQ,OAAO,EAAA;AAE/B,EAAA,OAAO,UAAA,CAAW,GAAA;AAAA,IAAI,CAAC,CAAA,EAAA,GACrB,qCAAA,CAAO,EAAA,EAAI,WAAA,CAAY,CAAuB,EAAA,EAAI,CAAA,CAAE;AAAA,EACtD,CAAA,CAAE,IAAA,CAAK,IAAI,CAAA;AACb,CAAA;AAQA,IAAM,UAAA,EAAY,CAAC,EAAE,WAAW,CAAA,EAAY,MAAA,EAAQ,CAAA,EAAA,GAAc;AAChE,EAAA,GAAA,CAAI,CAAC,UAAA,CAAW,MAAA,EAAQ,OAAO,EAAA;AAE/B,EAAA,MAAM,YAAA,EAAc,UAAA,CAAW,OAAA,IAAW,EAAA,GAAK,CAAC,qCAAA,UAAM,CAAW,CAAC,CAAC,CAAA;AACnE,EAAA,MAAM,MAAA,EAAQ,MAAA,GAAS,CAAC,YAAA,EAAc,IAAA,CAAK,MAAA,CAAO,KAAK,EAAA,EAAI,EAAA;AAE3D,EAAA,OAAO,UAAA,CACJ,MAAA,CAAO,CAAC,CAAA,EAAA,GAAM,CAAA,CAAE,SAAA,IAAa,UAAU,CAAA,CACvC,GAAA,CAAI,CAAC,CAAA,EAAA,GAAM,qCAAA,CAAO,EAAA,EAAI,SAAA,CAAU,CAAA,EAAG,KAAK,EAAA,EAAI,MAAA,EAAQ,CAAA,CAAE,SAAS,CAAA,CAC/D,IAAA,CAAK,IAAI,CAAA;AACd,CAAA;AAQA,IAAM,UAAA,EAAY,CAAC,IAAA,EAAe,MAAA,EAAQ,CAAA,EAAA,GAAc;AACtD,EAAA,MAAM,MAAA,EAAQ,MAAA,EAAQ,IAAA,CAAK,MAAA,CAAO,KAAK,EAAA,EAAI,EAAA;AAC3C,EAAA,MAAM,EAAE,UAAA,EAAY,OAAA,EAAS,WAAW,EAAA,EAAI,IAAA;AAC5C,EAAA,MAAM,YAAA,EAAc,UAAA,CAAW,OAAA,EAAS,CAAA;AACxC,EAAA,MAAM,YAAA,EAAc,UAAA,CAAW,OAAA,IAAW,EAAA,GAAK,CAAC,qCAAA,UAAM,CAAW,CAAC,CAAC,CAAA;AACnE,EAAA,MAAM,cAAA,EAAgB,UAAA,CAAW,KAAA,EAAO,CAAA;AACxC,EAAA,MAAM,cAAA,EAAgB,iCAAA,CAAgB,GAAA,CAAI,OAAO,CAAA;AAEjD,EAAA,MAAM,QAAA,EAAU,cAAA,EACZ,IAAA,EAAM,KAAA,CAAM,IAAA,CAAK,UAAU,CAAA,CAC1B,GAAA,CAAI,CAAC,CAAC,GAAA,EAAK,GAAG,CAAA,EAAA,GAAM,CAAA,EAAA;AAI6C,EAAA;AACvB,EAAA;AACM,EAAA;AACb,EAAA;AAAe;AACV,EAAA;AAEtC,EAAA;AACT;AAW0B;AACjB,EAAA;AACL,IAAA;AACgD,IAAA;AAClD,EAAA;AACF;AAgBsD;AACrB,EAAA;AACK,EAAA;AACD,EAAA;AACH,EAAA;AACF,EAAA;AAEjB,EAAA;AACX,IAAA;AACgC,IAAA;AACH,MAAA;AACL,QAAA;AAC0B,UAAA;AAC9C,QAAA;AACqB,QAAA;AACH,QAAA;AACF,UAAA;AACK,UAAA;AACU,0BAAA;AAGL,UAAA;AACX,YAAA;AACG,cAAA;AACc,cAAA;AAC5B,YAAA;AACW,YAAA;AACG,cAAA;AACc,cAAA;AAC5B,YAAA;AACD,UAAA;AACH,QAAA;AAEwB,QAAA;AAAA;AAET,UAAA;AACC,YAAA;AACgB,YAAA;AAC9B,UAAA;AAAA;AAEY,UAAA;AACE,YAAA;AACD,YAAA;AACb,UAAA;AACe,UAAA;AACD,YAAA;AACD,YAAA;AACb,UAAA;AACe,UAAA;AACD,YAAA;AACD,YAAA;AACb,UAAA;AACD,QAAA;AAEoB,QAAA;AACG,UAAA;AACxB,QAAA;AACF,MAAA;AACF,IAAA;AACe,IAAA;AACA,MAAA;AACK,MAAA;AACE,MAAA;AACtB,IAAA;AAAA;AAGwC,IAAA;AAOpC,MAAA;AACqB,QAAA;AACnB,UAAA;AACA,UAAA;AACA,UAAA;AACG,UAAA;AACL,QAAA;AACF,MAAA;AAQE,MAAA;AACmE,QAAA;AACrE,MAAA;AAC+B,MAAA;AACa,QAAA;AAC5C,MAAA;AACgC,MAAA;AACS,QAAA;AACzC,MAAA;AAC2B,MAAA;AACsC,QAAA;AACjE,MAAA;AACF,IAAA;AAAA;AAGqB,IAAA;AACO,MAAA;AACmC,QAAA;AAC7D,MAAA;AACF,IAAA;AAAA;AAEkC,IAAA;AACK,MAAA;AACzB,QAAA;AACR,UAAA;AACF,QAAA;AACF,MAAA;AAC+D,MAAA;AACtD,QAAA;AACT,MAAA;AAE8B,MAAA;AACR,MAAA;AACQ,QAAA;AACnB,UAAA;AACT,QAAA;AAC8B,QAAA;AAChC,MAAA;AACO,MAAA;AACT,IAAA;AACkC,IAAA;AACM,MAAA;AAC1B,QAAA;AACR,UAAA;AACF,QAAA;AACF,MAAA;AAE2D,MAAA;AAErC,MAAA;AACI,QAAA;AACK,QAAA;AAEI,QAAA;AAEK,QAAA;AACpB,QAAA;AAEiB,wBAAA;AACrC,MAAA;AAE+B,MAAA;AAES,MAAA;AAC1C,IAAA;AACgD,IAAA;AAEgB,MAAA;AACpC,MAAA;AAC5B,IAAA;AACgC,IAAA;AACiB,MAAA;AACjD,IAAA;AACmC,IAAA;AACW,MAAA;AAC9C,IAAA;AACsC,IAAA;AAGc,MAAA;AACpD,IAAA;AAC0C,IAAA;AACf,MAAA;AACmB,QAAA;AACY,QAAA;AACvD,MAAA;AACH,IAAA;AACF,EAAA;AAGuB,EAAA;AACT,IAAA;AACE,MAAA;AACD,MAAA;AACb,IAAA;AACU,IAAA;AACI,MAAA;AACD,MAAA;AACb,IAAA;AAAA;AAGI,IAAA;AACe,MAAA;AACD,QAAA;AACe,QAAA;AACX,UAAA;AAChB,QAAA;AACF,MAAA;AAEC,IAAA;AACN,EAAA;AAGe,EAAA;AACS,IAAA;AAChB,MAAA;AACS,QAAA;AACD,QAAA;AACb,MAAA;AACiB,MAAA;AACH,QAAA;AACsD,QAAA;AACpE,MAAA;AACM,MAAA;AACQ,QAAA;AACsD,QAAA;AACpE,MAAA;AACM,MAAA;AACQ,QAAA;AACsD,QAAA;AACpE,MAAA;AACU,MAAA;AACI,QAAA;AACe,QAAA;AACX,UAAA;AAChB,QAAA;AACF,MAAA;AACY,MAAA;AACE,QAAA;AACe,QAAA;AACI,UAAA;AAEE,UAAA;AACjC,QAAA;AACF,MAAA;AACD,IAAA;AACH,EAAA;AAGwB,EAAA;AACG,IAAA;AAC3B,EAAA;AAEO,EAAA;AACT;AAE0D;AACpC,EAAA;AACgC,IAAA;AACL,IAAA;AAC/C,EAAA;AACO,EAAA;AACT;AAeW;AAC0B,EAAA;AACM,EAAA;AAI9B,EAAA;AAC2B,IAAA;AAEQ,MAAA;AACrC,IAAA;AAC8D,MAAA;AACrE,IAAA;AACF,EAAA;AAGmD,EAAA;AAC3B,EAAA;AAEA,EAAA;AACtB,IAAA;AACmB,IAAA;AAChB,IAAA;AACL,EAAA;AAEwC,EAAA;AACL,EAAA;AACC,IAAA;AACpC,EAAA;AAEuB,EAAA;AACZ,IAAA;AACK,MAAA;AACD,MAAA;AACb,IAAA;AACY,IAAA;AACE,MAAA;AACD,MAAA;AACb,IAAA;AACI,IAAA;AACU,MAAA;AACuB,MAAA;AACrC,IAAA;AACW,IAAA;AACG,MAAA;AAC0B,MAAA;AACxC,IAAA;AACD,EAAA;AAEwD,EAAA;AACK,EAAA;AACjB,EAAA;AACT,IAAA;AACpC,EAAA;AACuE,EAAA;AAEzC,EAAA;AAC6B,EAAA;AACvB,IAAA;AACpC,EAAA;AAEqC,EAAA;AACiC,IAAA;AACjC,IAAA;AACV,IAAA;AACM,IAAA;AACQ,MAAA;AAC5B,QAAA;AACT,MAAA;AAC8B,MAAA;AAChC,IAAA;AACO,IAAA;AACT,EAAA;AAEO,EAAA;AACT;AAQmC;AF/CiD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/artae/Work/Github/domparser/dist/chunk-R4DWLBYH.cjs","sourcesContent":[null,"// selectors.ts\nimport { startsWith, toLowerCase } from \"./util.ts\";\nimport type { DOMNode, MatchFunction, SelectorPart } from \"./types.ts\";\n\n/**\n * Create a selector cache to help improve `match` based queries\n * (matches, querySelector, querySelectorAll).\n */\nclass SelectorCacheMap extends Map<string, MatchFunction> {\n  private hits = 0;\n  private misses = 0;\n\n  constructor() {\n    super();\n    this.misses = 0;\n    this.hits = 0;\n  }\n  hit() {\n    this.hits += 1;\n  }\n  miss() {\n    this.hits += 1;\n  }\n  getMatchFunction(selector: string, maxSize = 100): MatchFunction {\n    let matchFn = this.get(selector);\n\n    if (!matchFn) {\n      this.miss();\n      // If cache is full, remove oldest entry\n      if (this.size >= maxSize) {\n        const firstKey = this.keys().next().value;\n        /* istanbul ignore else @preserve */\n        if (firstKey) this.delete(firstKey);\n      }\n\n      // Parse selector parts once and create a matcher function\n      const parts = selector.split(\",\").map((s) => s.trim());\n\n      matchFn = (node: DOMNode): boolean =>\n        parts.some((part) => matchesSingleSelector(node, part));\n\n      this.set(selector, matchFn);\n    } else {\n      this.hit();\n    }\n\n    return matchFn;\n  }\n  clear() {\n    super.clear();\n    this.misses = 0;\n    this.hits = 0;\n  }\n  getStats() {\n    return {\n      size: this.size,\n      hits: this.hits,\n      misses: this.misses,\n      // prevent division by ZERO\n      hitRate: this.hits / ((this.hits + this.misses) || 1),\n    };\n  }\n}\n\nexport const selectorCache = new SelectorCacheMap();\n\n// Selector RegExp\nconst SELECTOR_REGEX = /([.#]?[\\w-]+|\\[[\\w-]+(?:=[^\\]]+)?\\])+/g;\n\n/**\n * Parses a CSS selector string into an array of selector parts.\n * Each part represents a segment of the selector (e.g., tag name, class, id, attribute).\n * @param selector The CSS selector string to parse.\n * @returns An array of `SelectorPart` objects representing the parsed selector.\n */\nconst parseSelector = (selector: string): SelectorPart[] => {\n  const parts: SelectorPart[] = [];\n  const matches =\n    selector.match(SELECTOR_REGEX) || /* istanbul ignore next @preserve */ [];\n\n  for (const match of matches) {\n    if (startsWith(match, \"#\")) {\n      parts.push({ type: \"#\", name: \"id\", value: match.slice(1) });\n    } else if (startsWith(match, \".\")) {\n      parts.push({ type: \".\", name: \"class\", value: match.slice(1) });\n    } else if (startsWith(match, \"[\")) {\n      const [name, value] = match.slice(1, -1).split(\"=\");\n      parts.push({\n        type: \"[\",\n        name,\n        value: value ? value.replace(/['\"]/g, \"\") : undefined,\n      });\n    } else {\n      parts.push({ type: \"\", name: match });\n    }\n  }\n  return parts;\n};\n\n/**\n * Checks if a node matches a single CSS selector.\n * @param node The `DOMNode` object to test against the selector.\n * @param selector The CSS selector string.\n * @returns `true` if the node matches the selector, `false` otherwise.\n */\nconst matchesSingleSelector = (node: DOMNode, selector: string): boolean => {\n  const parts = parseSelector(selector);\n\n  return parts.every((part) => {\n    switch (part.type) {\n      case \"#\": {\n        return node.attributes.get(\"id\") === part.value;\n      }\n      case \".\": {\n        const classes = node.attributes.get(\"class\")?.split(/\\s+/) || [];\n        return classes.includes(part.value as string);\n      }\n      case \"[\": {\n        const attrValue = node.attributes.get(part.name);\n        return part.value ? attrValue === part.value : attrValue !== undefined;\n      }\n      default: {\n        return toLowerCase(node.tagName) === toLowerCase(part.name);\n      }\n    }\n  });\n};\n\n/**\n * Checks if a node matches one or mode CSS selectors.\n * @param node The `DOMNode` object to test against the selector.\n * @param selector The CSS selector string.\n * @returns `true` if the node matches the selector, `false` otherwise.\n */\nexport const matchesSelector = (node: DOMNode, selector: string): boolean => {\n  const matcher = selectorCache.getMatchFunction(selector);\n  return matcher(node);\n};\n","// prototype.ts\nimport { tokenize } from \"./util.ts\";\nimport { matchesSelector } from \"./selectors.ts\";\nimport {\n  defineProperties,\n  DOM_ERROR,\n  isNode,\n  isObj,\n  isPrimitive,\n  isRoot,\n  isTag,\n  selfClosingTags,\n  toUpperCase,\n} from \"./util.ts\";\n\nimport type {\n  ChildElementList,\n  ChildNode,\n  ChildNodeList,\n  CommentNode,\n  DOMNode,\n  MaybeChildNode,\n  NodeLikeAttributes,\n  RootNode,\n  TagNames,\n  TextNode,\n  TextToken,\n} from \"./types.ts\";\n\n/**\n * Generates text string from node's children textContent.\n * @param node The node whose children to stringify\n * @returns textContent string\n */\nconst textContent = (node: ChildNode): string => {\n  if (!isTag(node)) return node.nodeValue;\n  const { childNodes } = node;\n  if (!childNodes.length) return \"\";\n\n  return childNodes.map((n) =>\n    isTag(n) ? textContent(n as unknown as DOMNode) : n.nodeValue\n  ).join(\"\\n\");\n};\n\n/**\n * Generates HTML string for node's children\n * @param node The node whose children to stringify\n * @param depth Current indentation depth\n * @returns innerHTML string\n */\nconst innerHTML = ({ childNodes }: DOMNode, depth = 0): string => {\n  if (!childNodes.length) return \"\";\n\n  const childIsText = childNodes.length === 1 && !isTag(childNodes[0]);\n  const space = depth && !childIsText ? \"  \".repeat(depth) : \"\";\n\n  return childNodes\n    .filter((n) => n.nodeName !== \"#comment\")\n    .map((n) => isTag(n) ? outerHTML(n, depth) : space + n.nodeValue)\n    .join(\"\\n\");\n};\n\n/**\n * Generates HTML string for a node including its opening/closing tags\n * @param node The node to stringify\n * @param depth Current indentation depth\n * @returns outerHTML string\n */\nconst outerHTML = (node: DOMNode, depth = 0): string => {\n  const space = depth ? \"  \".repeat(depth) : \"\";\n  const { attributes, tagName, childNodes } = node;\n  const hasChildren = childNodes.length > 0;\n  const childIsText = childNodes.length === 1 && !isTag(childNodes[0]);\n  const hasAttributes = attributes.size > 0;\n  const isSelfClosing = selfClosingTags.has(tagName);\n\n  const attrStr = hasAttributes\n    ? \" \" + Array.from(attributes)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .join(\" \")\n    : \"\";\n\n  let output = `${space}<${tagName}${attrStr}${isSelfClosing ? \" /\" : \"\"}>`;\n  output += hasChildren && !childIsText ? \"\\n\" : \"\";\n  output += hasChildren ? innerHTML(node, depth + 1) : \"\";\n  output += !childIsText && hasChildren ? `\\n${space}` : \"\";\n  output += !isSelfClosing ? `</${tagName}>` : \"\";\n\n  return output;\n};\n\n/**\n * Creates a basic text or comment node.\n * @param nodeName The node name (\"#text\" or \"#comment\").\n * @param text The text content of the node.\n * @returns A TextNode or CommentNode object.\n */\nexport function createBasicNode<T extends (\"#text\" | \"#comment\")>(\n  nodeName: T,\n  text: string,\n): TextNode | CommentNode {\n  return {\n    nodeName,\n    nodeValue: nodeName !== \"#text\" ? `<${text}>` : text,\n  } as (TextNode | CommentNode);\n}\n\n/**\n * Creates a DOM-like Node (`DOMNode` or `RootNode`) with DOM API properties and methods.\n * This function extends the basic `NodeLike` from **Parser** by adding DOM-specific\n * properties and methods, as well as applying filters based on the provided configuration.\n *\n * @param this - The `RootNode` when creating a `DOMNode`, or `null` otherwise (in non-strict mode)\n * @param nodeName The tag name of the node to create (or '#document' for the root).\n * @param childNodes Optional child nodes to append to the created node.\n * @returns An extended `DOMNode` or `RootNode` object with DOM API.\n */\nexport function createNode(\n  this: RootNode | null,\n  nodeName: string,\n  ...childNodes: ChildNodeList\n): Omit<DOMNode, \"tagName\" | \"attributes\"> | RootNode {\n  const ALL: ChildElementList = [];\n  const CHILDREN: ChildElementList = [];\n  const CHILDNODES: ChildNodeList = [];\n  const nodeIsRoot = nodeName === \"#document\";\n  const ownerDocument = this ?? undefined;\n\n  const node = {\n    nodeName,\n    append(...nodes: ChildNodeList) {\n      for (const child of nodes) {\n        if (!isNode(child)) {\n          throw new Error(`${DOM_ERROR} Invalid node.`);\n        }\n        CHILDNODES.push(child);\n        if (isTag(child)) {\n          ALL.push(child);\n          CHILDREN.push(child);\n          ownerDocument?.register(child);\n\n          // Add HTML generation methods\n          defineProperties(child, {\n            innerHTML: {\n              enumerable: false,\n              get: () => innerHTML(child),\n            },\n            outerHTML: {\n              enumerable: false,\n              get: () => outerHTML(child),\n            },\n          });\n        }\n\n        defineProperties(child, {\n          // Add text generation methods\n          textContent: {\n            enumerable: false,\n            get: () => textContent(child),\n          },\n          // Add node relationship properties\n          parentNode: {\n            enumerable: false,\n            get: () => node,\n          },\n          parentElement: {\n            enumerable: false,\n            get: () => node,\n          },\n          ownerDocument: {\n            enumerable: false,\n            get: () => ownerDocument,\n          },\n        });\n\n        child.remove = () => {\n          node.removeChild(child);\n        };\n      }\n    },\n    cleanup: () => {\n      ALL.length = 0;\n      CHILDREN.length = 0;\n      CHILDNODES.length = 0;\n    },\n\n    // Root document methods\n    ...(isRoot({ nodeName } as RootNode) && {\n      createElement(\n        tagName:\n          & string\n          & (keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap),\n        first?: NodeLikeAttributes | MaybeChildNode,\n        ...rest: MaybeChildNode[]\n      ) {\n        return createElement.call(\n          node as RootNode,\n          tagName,\n          first,\n          ...rest,\n        );\n      },\n      createElementNS(\n        _ns: string,\n        tagName:\n          & string\n          & (keyof SVGElementTagNameMap & keyof HTMLElementTagNameMap),\n        first?: NodeLikeAttributes | MaybeChildNode,\n        ...rest: MaybeChildNode[]\n      ) {\n        return createElement.call(node as RootNode, tagName, first, ...rest);\n      },\n      createComment(content: string) {\n        return createBasicNode(\"#comment\", content);\n      },\n      createTextNode(content: string) {\n        return createBasicNode(\"#text\", content);\n      },\n      getElementById(id: string) {\n        return ALL.find((node) => node.attributes.get(\"id\") === id) ?? null;\n      },\n    }),\n\n    // Element methods\n    ...((!nodeIsRoot) && {\n      matches(selector: string) {\n        return matchesSelector(node as unknown as DOMNode, selector);\n      },\n    }),\n    // Shared methods\n    contains: (childNode: DOMNode) => {\n      if (!childNode || !isTag(childNode)) {\n        throw new Error(\n          \"DomError: the childNode parameter must be a valid DOMNode\",\n        );\n      }\n      if ((node as DOMNode | RootNode).children.includes(childNode)) {\n        return true;\n      }\n\n      let currentParent = childNode.parentNode;\n      while (currentParent) {\n        if (currentParent === node) {\n          return true;\n        }\n        currentParent = currentParent.parentNode;\n      }\n      return false;\n    },\n    removeChild(childNode: ChildNode) {\n      if (!childNode || !isNode(childNode)) {\n        throw new Error(\n          \"DomError: the childNode parameter must be a valid ChildNode\",\n        );\n      }\n\n      const indexOf = (arr: ChildNode[]) => arr.indexOf(childNode);\n      /* istanbul ignore else @preserve */\n      if (isTag(childNode)) {\n        const idx1 = indexOf(ALL);\n        const idx2 = indexOf(CHILDREN);\n        /* istanbul ignore else @preserve */\n        if (idx1 > -1) ALL.splice(idx1, 1);\n        /* istanbul ignore else @preserve */\n        if (idx2 > -1) CHILDREN.splice(idx2, 1);\n        childNode.cleanup();\n\n        ownerDocument?.deregister(childNode);\n      }\n\n      const idx3 = indexOf(CHILDNODES);\n      /* istanbul ignore else @preserve */\n      if (idx3 > -1) CHILDNODES.splice(idx3, 1);\n    },\n    replaceChildren: (...newChildren: DOMNode[]) => {\n      // clone this array to work\n      CHILDNODES.slice(0).forEach((child) => node.removeChild(child));\n      node.append(...newChildren);\n    },\n    querySelector(selector: string) {\n      return ALL.find((n) => n.matches(selector)) ?? null;\n    },\n    querySelectorAll(selector: string) {\n      return ALL.filter((n) => n.matches(selector));\n    },\n    getElementsByTagName(tagName: string) {\n      return tagName === \"*\"\n        ? ALL\n        : ALL.filter((n) => n.tagName.toLowerCase() === tagName.toLowerCase());\n    },\n    getElementsByClassName(className: string) {\n      return ALL.filter((n) => {\n        const classAttr = n.attributes.get(\"class\");\n        return classAttr?.split(/\\s+/).includes(className) ?? false;\n      });\n    },\n  };\n\n  // Define enumerable getters\n  defineProperties(node, {\n    childNodes: {\n      enumerable: true,\n      get: () => CHILDNODES,\n    },\n    children: {\n      enumerable: true,\n      get: () => CHILDREN,\n    },\n    // Add tag-specific property\n    ...(!nodeIsRoot\n      ? {\n        registerChild: {\n          enumerable: false,\n          value: (child: DOMNode) => {\n            ALL.push(child);\n          },\n        },\n      }\n      : {}),\n  });\n\n  // Add root-specific properties\n  if (nodeIsRoot) {\n    defineProperties(node, {\n      all: {\n        enumerable: true,\n        get: () => ALL,\n      },\n      documentElement: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"HTML\"),\n      },\n      head: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"HEAD\"),\n      },\n      body: {\n        enumerable: true,\n        get: () => ALL.find((node) => toUpperCase(node.tagName) === \"BODY\"),\n      },\n      register: {\n        enumerable: false,\n        value: (child: DOMNode) => {\n          ALL.push(child);\n        },\n      },\n      deregister: {\n        enumerable: false,\n        value: (child: DOMNode) => {\n          const idx = ALL.indexOf(child);\n          /* istanbul ignore else @preserve */\n          if (idx > -1) ALL.splice(idx, 1);\n        },\n      },\n    });\n  }\n\n  // Add any initial children\n  if (childNodes?.length) {\n    node.append(...childNodes);\n  }\n\n  return node as unknown as RootNode | Omit<DOMNode, \"tagName\" | \"attributes\">;\n}\n\nconst convertToNode = (n: string | number | ChildNode) => {\n  if (isPrimitive(n)) {\n    const { tokenType, value } = tokenize(String(n))[0] as TextToken;\n    return createBasicNode(`#${tokenType}`, value);\n  }\n  return n;\n};\n\n/**\n * Creates a new `Element` like node\n * @param this The RootNode instance\n * @param tagName Tag name for the element\n * @param first Optional attributes or first child\n * @param args Additional child nodes\n * @returns New element node\n */\nexport function createElement(\n  this: RootNode,\n  tagName: string & TagNames,\n  first?: NodeLikeAttributes | MaybeChildNode,\n  ...args: MaybeChildNode[]\n): DOMNode {\n  const childNodes: ChildNodeList = [];\n  let attributes = new Map<string, string>();\n\n  // Handle first argument\n  /* istanbul ignore else @preserve */\n  if (first) {\n    if (isObj(first) && !isNode(first)) {\n      // Convert attributes object to Map\n      attributes = new Map(Object.entries(first));\n    } else {\n      childNodes.push(convertToNode(first as string | number | ChildNode));\n    }\n  }\n\n  // Add remaining children\n  const nodes = args.map(convertToNode).filter(isNode);\n  childNodes.push(...nodes);\n\n  const node = createNode.call(\n    this,\n    toUpperCase(tagName),\n    ...childNodes,\n  ) as DOMNode;\n\n  const charset = attributes.get(\"charset\");\n  if (tagName === \"meta\" && charset) {\n    this.charset = toUpperCase(charset);\n  }\n\n  defineProperties(node, {\n    tagName: {\n      enumerable: true,\n      get: () => tagName,\n    },\n    attributes: {\n      enumerable: true,\n      get: () => attributes,\n    },\n    id: {\n      enumerable: true,\n      get: () => attributes.get(\"id\") ?? \"\",\n    },\n    className: {\n      enumerable: true,\n      get: () => attributes.get(\"class\") ?? \"\",\n    },\n  });\n  // define Element attributes methods\n  node.hasAttribute = (attrName) => attributes.has(attrName);\n  node.getAttribute = (attrName) => attributes.get(attrName) ?? null;\n  node.setAttribute = (attrName, attrValue) => {\n    attributes.set(attrName, attrValue);\n  };\n  node.hasAttributeNS = (_namespace, attrName) => attributes.has(attrName);\n  node.getAttributeNS = (_namespace, attrName) =>\n    attributes.get(attrName) ?? null;\n  node.setAttributeNS = (_namespace, attrName, attrValue) => {\n    attributes.set(attrName, attrValue);\n  };\n  // define Element parent selector\n  node.closest = (selector: string) => {\n    if (!selector) throw new Error(\"DomError: selector must be a string\");\n    if (node.matches(selector)) return node;\n    let currentParent = node.parentNode;\n    while (!isRoot(currentParent)) {\n      if (currentParent.matches(selector)) {\n        return currentParent;\n      }\n      currentParent = currentParent.parentNode;\n    }\n    return null;\n  };\n\n  return node;\n}\n\n/**\n * Creates a new `Document` like root node.\n *\n * @returns a new root node\n */\nexport const createDocument = () =>\n  createNode.call(null, \"#document\") as RootNode;\n"]}