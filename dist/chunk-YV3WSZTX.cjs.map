{"version":3,"sources":["/home/artae/Work/Github/domparser/dist/chunk-YV3WSZTX.cjs","../src/parts/dom-parser.ts"],"names":[],"mappings":"AAAA;AACE;AACA;AACA;AACF,wDAA6B;AAC7B;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACF,wDAA6B;AAC7B;AACA;ACwCO,IAAM,UAAA,EAAY,CACvB,MAAA,EAAA,GACG;AACH,EAAA,GAAA,CAAI,OAAA,GAAU,CAAC,qCAAA,MAAY,CAAA,EAAG;AAC5B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,EAAA;AAClB,EAAA;AAGiB,EAAA;AACb,EAAA;AAGc,EAAA;AAGV,EAAA;AACQ,EAAA;AACC,EAAA;AACX,EAAA;AAGC,EAAA;AACW,IAAA;AACV,MAAA;AACQ,QAAA;AACZ,MAAA;AACa,MAAA;AACR,MAAA;AAEkC,MAAA;AACjC,MAAA;AACA,MAAA;AACO,MAAA;AACE,MAAA;AACF,MAAA;AACT,MAAA;AAES,MAAA;AACH,QAAA;AAGJ,QAAA;AACG,UAAA;AACL,UAAA;AACF,QAAA;AACM,QAAA;AACA,QAAA;AACA,QAAA;AACA,QAAA;AAGF,QAAA;AAEG,UAAA;AAEM,YAAA;AAEJ,UAAA;AAEC,YAAA;AACF,YAAA;AACE,cAAA;AACF,gBAAA;AACK,kBAAA;AACL,gBAAA;AACK,cAAA;AACL,gBAAA;AACK,kBAAA;AACL,gBAAA;AACF,cAAA;AACF,YAAA;AACF,UAAA;AACF,QAAA;AAGI,QAAA;AACG,UAAA;AACE,YAAA;AACH,cAAA;AACK,YAAA;AACL,cAAA;AACF,YAAA;AACF,UAAA;AACA,UAAA;AACF,QAAA;AAGI,QAAA;AAES,QAAA;AACD,UAAA;AACJ,YAAA;AACJ,YAAA;AACF,UAAA;AACA,UAAA;AACA,UAAA;AACF,QAAA;AAGU,QAAA;AAIL,QAAA;AACG,UAAA;AACI,UAAA;AACR,YAAA;AACA,YAAA;AACA,YAAA;AACF,UAAA;AACA,UAAA;AACM,UAAA;AAAkB,YAAA;AAExB,UAAA;AAEI,UAAA;AAEE,UAAA;AACF,UAAA;AACG,YAAA;AACP,UAAA;AAEC,UAAA;AACS,QAAA;AACA,UAAA;AACZ,QAAA;AACF,MAAA;AAIa,MAAA;AACL,QAAA;AACI,QAAA;AACZ,MAAA;AAEO,MAAA;AACL,QAAA;AACY,QAAA;AACA,QAAA;AACd,MAAA;AACF,IAAA;AACF,EAAA;AACF;AD3EqB;AACA;AACA;AACA","file":"/home/artae/Work/Github/domparser/dist/chunk-YV3WSZTX.cjs","sourcesContent":[null,"// dom-parser.ts\nimport { createBasicNode, createDocument, createElement } from \"./prototype.ts\";\nimport type {\n  ChildNode,\n  DOMNode,\n  DomParserOptions,\n  DomParserResult,\n  GetAttributesOptions,\n  RootNode,\n} from \"./types.ts\";\n\nimport {\n  DOM_ERROR,\n  getAttributes,\n  isObj,\n  selfClosingTags,\n  startsWith,\n  tokenize,\n  toUpperCase,\n} from \"./util.ts\";\n\n/**\n * **DomParser**\n *\n * Unlike the basic **Parser**, **DomParser** creates a new `Document` like instance with DOM-like\n * methods and properties and populates it with `Node` like objects resulted from the parsing\n * of a given HTML markup.\n *\n * @example\n * ```ts\n * const config = {\n *   // On creating new node callback function\n *   onNodeCallback?: myFunction(node: DOMNode) => DOMNode | YOURNode,\n *   // Common dangerous tags that could lead to XSS attacks\n *   filterTags: [\n *     \"script\", \"style\", \"iframe\", \"object\", \"embed\", \"base\", \"form\",\n *     \"input\", \"button\", \"textarea\", \"select\", \"option\"\n *   ],\n *   // Unsafe attributes that could lead to XSS attacks\n *   filterAttrs: [\n *     \"onerror\", \"onload\", \"onunload\", \"onclick\", \"ondblclick\", \"onmousedown\",\n *     \"onmouseup\", \"onmouseover\", \"onmousemove\", \"onmouseout\", \"onkeydown\",\n *     \"onkeypress\", \"onkeyup\", \"onchange\", \"onsubmit\", \"onreset\", \"onselect\",\n *     \"onblur\", \"onfocus\", \"formaction\", \"href\", \"xlink:href\", \"action\"\n *   ]\n * }\n * const { root: doc, components, tags } = DomParser.parseFromString(\"<!doctype html><html>This is starting html</html>\", config);\n * console.log(doc.documentElement.outerHTML);\n * // > \"<html>This is starting html</html>\"\n * ```\n *\n * @param startHTML Initial HTML content\n * @param config the `Parser` options to apply to the parsing of the startHTML markup.\n * @returns The `Document` like root node\n */\nexport const DomParser = (\n  config?: Partial<DomParserOptions>,\n) => {\n  if (config && !isObj(config)) {\n    throw new Error(`${DOM_ERROR} 1st parameter is not an object.`);\n  }\n\n  // Common dangerous tags that could lead to XSS\n  let unsafeTags = new Set<string>();\n  let unsafeTagDepth = 0;\n\n  // Unsafe attributes that could lead to XSS\n  let unsafeAttrs = new Set<string>();\n\n  // Apply config\n  const { filterTags, filterAttrs, onNodeCallback } = config || {};\n  if (filterTags?.length) unsafeTags = new Set(filterTags);\n  if (filterAttrs?.length) unsafeAttrs = new Set(filterAttrs);\n  const getAttrOptions = { unsafeAttrs } as GetAttributesOptions;\n  // don't override the default function unless it's actualy set\n\n  return {\n    parseFromString(htmlString?: string) {\n      if (htmlString && typeof htmlString !== \"string\") {\n        throw new Error(`${DOM_ERROR} 1st parameter is not a string.`);\n      }\n      const root = createDocument();\n      if (!htmlString) return { root, components: [], tags: [] };\n\n      const stack: (RootNode | DOMNode)[] = [root];\n      const tagStack: string[] = [];\n      const components = new Set<string>();\n      const tags = new Set<string>();\n      const tokens = tokenize(htmlString);\n      const tLen = tokens.length;\n      let newNode: ChildNode;\n\n      for (let i = 0; i < tLen; i += 1) {\n        const { tokenType, value, isSC } = tokens[i];\n\n        // Skip doctype, but store it as a root property\n        if (tokenType === \"doctype\") {\n          root.doctype = `<${value}>`;\n          continue;\n        }\n        const currentParent = stack[stack.length - 1];\n        const isClosing = startsWith(value, \"/\");\n        const tagName = isClosing ? value.slice(1) : value.split(/[\\s/>]/)[0];\n        const isSelfClosing = isSC || selfClosingTags.has(tagName);\n\n        // Tag Matching Detection Logic\n        if (tokenType === \"tag\" && !isSelfClosing) {\n          // Start Tag (and not self-closing)\n          if (!isClosing) {\n            // Push tag name onto the tag stack\n            tagStack.push(tagName);\n            // Closing Tag\n          } else {\n            // Pop the last opened tag\n            const expectedTag = tagStack.pop();\n            if (expectedTag !== tagName) {\n              if (expectedTag === undefined) {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. No open tag found.`,\n                );\n              } else {\n                throw new Error(\n                  `${DOM_ERROR} Mismatched closing tag: </${tagName}>. Expected closing tag for <${expectedTag}>.`,\n                );\n              }\n            }\n          }\n        }\n\n        // Skip unsafe tags AND their children\n        if (unsafeTags.has(tagName)) {\n          if (!isSelfClosing) {\n            if (!isClosing) {\n              unsafeTagDepth++;\n            } else {\n              unsafeTagDepth--;\n            }\n          }\n          continue;\n        }\n\n        // Don't process anything while inside unsafe tags\n        if (unsafeTagDepth > 0) continue;\n\n        if ([\"text\", \"comment\"].includes(tokenType)) {\n          newNode = createBasicNode(\n            `#${tokenType as \"text\" | \"comment\"}`,\n            value,\n          ) as ChildNode;\n          currentParent.append(newNode);\n          continue;\n        }\n\n        // Register tag/component type\n        (tagName[0] === toUpperCase(tagName[0]) || tagName.includes(\"-\")\n          ? components\n          : tags).add(tagName);\n\n        if (!isClosing) {\n          const attributes = getAttributes(value, getAttrOptions);\n          newNode = createElement.call(\n            root,\n            tagName as DOMNode[\"tagName\"],\n            attributes,\n          );\n          currentParent.append(newNode);\n          stack.slice(1, -1).map((parent) =>\n            (parent as DOMNode).registerChild(newNode as DOMNode)\n          );\n\n          if (onNodeCallback) onNodeCallback(newNode, currentParent, root);\n\n          const charset = attributes?.charset;\n          if (tagName === \"meta\" && charset) {\n            root.charset = toUpperCase(charset);\n          }\n\n          !isSelfClosing && stack.push(newNode);\n        } else if (!isSelfClosing && stack.length > 1) {\n          stack.pop();\n        }\n      }\n\n      // Check for unclosed tags at the end\n      // an edge case where end tag is malformed `</incomplete`\n      if (tagStack.length > 0) {\n        const unclosedTag = tagStack.pop();\n        throw new Error(`${DOM_ERROR} Unclosed tag: <${unclosedTag}>.`);\n      }\n\n      return {\n        root,\n        components: Array.from(components),\n        tags: Array.from(tags),\n      } satisfies DomParserResult;\n    },\n  };\n};\n"]}